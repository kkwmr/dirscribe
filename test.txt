üìÅ dirscribe/
  üìÅ .git/
    üìÅ branches/
    üìÑ COMMIT_EDITMSG
    üìÑ config
    üìÑ description
    üìÑ HEAD
    üìÅ hooks/
      üìÑ applypatch-msg.sample
      üìÑ commit-msg.sample
      üìÑ fsmonitor-watchman.sample
      üìÑ post-update.sample
      üìÑ pre-applypatch.sample
      üìÑ pre-commit.sample
      üìÑ pre-merge-commit.sample
      üìÑ pre-push.sample
      üìÑ pre-rebase.sample
      üìÑ pre-receive.sample
      üìÑ prepare-commit-msg.sample
      üìÑ update.sample
    üìÑ index
    üìÅ info/
      üìÑ exclude
    üìÅ logs/
      üìÑ HEAD
      üìÅ refs/
        üìÅ heads/
          üìÑ main
        üìÅ remotes/
          üìÅ origin/
            üìÑ main
    üìÅ objects/
      üìÅ 0e/
        üìÑ 7b24d3c34ff1d4f57029e12a0ed9a447afc2e1
      üìÅ 18/
        üìÑ 0791f3b9750e562dd96939752106089b678e2b
      üìÅ 19/
        üìÑ 1099e8aa4bc3b49c9f10485f3c83a258acb36b
      üìÅ 1b/
        üìÑ ae5d2e49942d13594c6f3aa2ea29915adf7b37
      üìÅ 36/
        üìÑ a73a7afd60aa9f24af32c3fccc8ec2f7f39fed
      üìÅ 3b/
        üìÑ 94d9b6343d903a398527621d433e935b852607
      üìÅ 44/
        üìÑ 54c8b82a45039e7129ba452368536bf60268ae
      üìÅ 4d/
        üìÑ 173a646bbdf257211ae246a798dff4724e7f51
      üìÅ 54/
        üìÑ 02ad3b254c098c7fe5074501f5fbddfe1bc25c
      üìÅ 55/
        üìÑ abe6269ff8a230d10ae9d88f3a45f73998026c
      üìÅ 5f/
        üìÑ 73c6ac039b84b5835e2ad4323a6cf9087ca84c
      üìÅ 60/
        üìÑ 3d4f67046cbfb5452df33959b64995d8f848a4
      üìÅ 61/
        üìÑ 9c23f76d0be9c213f69f54b83d925f53d85792
      üìÅ 71/
        üìÑ 77ec5c59c262e95e9d3e29f9900d640eb1209b
      üìÅ 72/
        üìÑ a99349f92ad6cdf65b86bcbc17e0115b0052c1
      üìÅ 7e/
        üìÑ b8a4a6807e48be35fdf1f129907e75229bf495
      üìÅ 8a/
        üìÑ 224a9eb9417670b1ca1a82b17f81b80651eb5b
      üìÅ 97/
        üìÑ 87c3bdf008a57ae3cb2e27a8261eb3f134ff73
      üìÅ a5/
        üìÑ b8b5610c39736debb58063a66d941589b31c01
      üìÅ a9/
        üìÑ 4546d944b15cdcb850afefd6575a1def7d9462
      üìÅ b8/
        üìÑ 0111c16d345d531c50507f3301a30437eff486
      üìÅ bf/
        üìÑ c68f8759cfb2bc629a1dab54353f0c61a41334
      üìÅ c4/
        üìÑ d04a08d024e901bb246cc8da9ccf6b49b31909
      üìÅ ca/
        üìÑ 1a7e5856f6d86106b40128981418e08b71627b
      üìÅ d5/
        üìÑ 3f8116ec79e4e38df364ca416ec71fc908ba19
      üìÅ d9/
        üìÑ 8dc5e36cf0c651f2b0bc0702d6fa5f339eba09
      üìÅ e0/
        üìÑ 35be5e92bb7fb071ed5bf616b35c8d449b61f3
      üìÅ f6/
        üìÑ c100e6d7b8539053c2afec43081ab07715f2ea
      üìÅ fb/
        üìÑ 96d0eb93178eaabf8967073e8a2a6d0b8b03a6
        üìÑ fd31beab538a41c3d047db65f569f8dac09885
      üìÅ info/
      üìÅ pack/
    üìÅ refs/
      üìÅ heads/
        üìÑ main
      üìÅ remotes/
        üìÅ origin/
          üìÑ main
      üìÅ tags/
        üìÑ v0.1.0
        üìÑ v0.1.1
  üìÑ .gitignore
  üìÅ .pytest_cache/
    üìÑ .gitignore
    üìÑ CACHEDIR.TAG
    üìÑ README.md
      # pytest cache directory #
      
      This directory contains data from the pytest's cache plugin,
      which provides the `--lf` and `--ff` options, as well as the `cache` fixture.
      
      **Do not** commit this to version control.
      
      See [the docs](https://docs.pytest.org/en/latest/cache.html) for more information.
    üìÅ v/
      üìÅ cache/
        üìÑ lastfailed
        üìÑ nodeids
        üìÑ stepwise
  üìÅ build/
    üìÅ bdist.linux-x86_64/
    üìÅ lib/
      üìÅ dirscribe/
        üìÑ __init__.py
          """
          DirScribe
          
          A Python package that helps you export a directory structure and optionally
          the contents of files with certain extensions.
          """
          
          __version__ = "0.1.1"
          
          from .core import export_directory_structure, main
        üìÑ core.py
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          
          import argparse
          import json
          import time
          import sys
          from pathlib import Path
          from typing import List, Optional, Union, Dict, Any
          
          try:
              import pyperclip
          except ImportError:
              pyperclip = None
          
          #: A default dictionary for mapping file extensions to language names.
          LANGUAGE_MAP = {
              ".py": "Python",
              ".js": "JavaScript",
              ".ts": "TypeScript",
              ".java": "Java",
              ".rb": "Ruby",
              ".php": "PHP",
              ".html": "HTML",
              ".css": "CSS",
              ".cpp": "C++",
              ".c": "C",
              ".go": "Go",
              ".rs": "Rust",
              ".swift": "Swift",
          }
          
          
          def scan_directory(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False
          ) -> Dict[str, Any]:
              """
              Recursively scans the target directory and builds a nested dictionary
              representing directories and files. File contents are included only for
              certain extensions if specified.
          
              Args:
                  target_dir (Path):
                      The directory path to scan.
                  include_extensions (List[str], optional):
                      A list of file extensions to include content for. If None, all files are included.
                      If an empty list, no file content is included.
                  skip_hidden (bool):
                      If True, hidden files and directories (names starting with '.') are skipped.
                  max_size (int, optional):
                      Maximum file size in bytes to read. Files larger than this are skipped.
                  show_metadata (bool):
                      If True, file metadata (size, modified time) is included in the output.
                  detect_language (bool):
                      If True, a "language" field is added to each file based on extension.
          
              Returns:
                  Dict[str, Any]: A nested dictionary describing the directory structure.
              """
              if not target_dir.exists():
                  return {
                      "type": "error",
                      "message": f"Directory does not exist: {target_dir}"
                  }
          
              tree = {
                  "type": "directory",
                  "name": target_dir.name,
                  "path": str(target_dir.resolve()),
                  "children": []
              }
          
              try:
                  entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
              except PermissionError:
                  tree["children"].append({
                      "type": "error",
                      "message": f"Permission denied: {target_dir}"
                  })
                  return tree
          
              for entry in entries:
                  # Skip hidden files/directories if skip_hidden == True
                  if skip_hidden and entry.name.startswith('.'):
                      continue
          
                  if entry.is_dir():
                      subtree = scan_directory(
                          entry,
                          include_extensions=include_extensions,
                          skip_hidden=skip_hidden,
                          max_size=max_size,
                          show_metadata=show_metadata,
                          detect_language=detect_language
                      )
                      tree["children"].append(subtree)
                  else:
                      file_node = {
                          "type": "file",
                          "name": entry.name,
                          "path": str(entry.resolve())
                      }
          
                      # Detect language if requested
                      if detect_language:
                          lang = LANGUAGE_MAP.get(entry.suffix.lower())
                          if lang:
                              file_node["language"] = lang
          
                      # Show metadata if requested
                      if show_metadata:
                          file_node["metadata"] = _get_file_metadata(entry)
          
                      # Decide if we include the file content
                      if include_extensions and len(include_extensions) > 0:
                          # If we put "ALL_MODE" into include_extensions, treat as "include all"
                          if "ALL_MODE" in include_extensions:
                              should_include = True
                          else:
                              should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                      elif include_extensions is None:
                          # If include_extensions is None, treat as "include all"
                          should_include = True
                      else:
                          # If it's an empty list, do not include file content
                          should_include = False
          
                      if should_include:
                          size = entry.stat().st_size
                          if max_size is not None and size > max_size:
                              file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                          else:
                              file_node["content"] = _read_file_content(entry)
          
                      tree["children"].append(file_node)
          
              return tree
          
          
          def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
              """
              Builds a list of text lines (ASCII tree style) from the nested dictionary.
          
              Args:
                  tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
                  indent_level (int): Internal parameter for managing indentation in recursion.
          
              Returns:
                  List[str]: A list of text lines representing the directory tree and optional contents.
              """
              lines = []
          
              node_type = tree.get("type")
              node_name = tree.get("name", "unknown")
          
              if node_type == "error":
                  msg = tree.get("message", "Unknown error")
                  lines.append("  " * indent_level + f"[Error] {msg}")
                  return lines
          
              if node_type == "directory":
                  lines.append("  " * indent_level + f"üìÅ {node_name}/")
                  children = tree.get("children", [])
                  for child in children:
                      lines.extend(build_text_output(child, indent_level + 1))
          
              elif node_type == "file":
                  language = tree.get("language")
                  if language:
                      lines.append("  " * indent_level + f"üìÑ {node_name} ({language})")
                  else:
                      lines.append("  " * indent_level + f"üìÑ {node_name}")
          
                  content = tree.get("content")
                  if content is not None:
                      for c_line in content.splitlines():
                          lines.append("  " * (indent_level + 1) + c_line)
          
                  metadata = tree.get("metadata")
                  if metadata:
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
          
              return lines
          
          
          def export_directory_structure(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False,
              output_format: str = "text",
              output_file: Optional[Path] = None
          ) -> Union[List[str], str]:
              """
              Scans the directory and produces output in either text or JSON format.
              Optionally writes the result to a file if output_file is specified.
          
              Args:
                  target_dir (Path): The directory to scan.
                  include_extensions (List[str], optional): File extensions to include contents for.
                      If None, includes all. If empty, includes none.
                  skip_hidden (bool): Whether to skip hidden files/directories.
                  max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
                  show_metadata (bool): Whether to include file metadata in the output.
                  detect_language (bool): Whether to add a 'language' field based on file extension.
                  output_format (str): 'text' or 'json'. Default is 'text'.
                  output_file (Path, optional): If specified, the output is written to this file.
          
              Returns:
                  Union[List[str], str]:
                      - If output_format='text' and output_file is None, returns a list of lines.
                      - If output_format='json' and output_file is None, returns a JSON string.
                      - If output_file is specified, writes to file and returns an empty list or string.
              """
              tree = scan_directory(
                  target_dir=target_dir,
                  include_extensions=include_extensions,
                  skip_hidden=skip_hidden,
                  max_size=max_size,
                  show_metadata=show_metadata,
                  detect_language=detect_language
              )
          
              if output_format not in ["text", "json"]:
                  raise ValueError("Invalid output format. Choose 'text' or 'json'.")
          
              if output_format == "text":
                  output_data = build_text_output(tree)
              else:
                  output_data = json.dumps(tree, indent=2)
          
              if output_file is not None:
                  if output_format == "text":
                      # output_data is a list of strings
                      text_content = "\n".join(output_data)
                      output_file.write_text(text_content, encoding="utf-8")
                      return []
                  else:
                      # output_data is a JSON string
                      output_file.write_text(output_data, encoding="utf-8")
                      return ""
              else:
                  return output_data
          
          
          def main():
              """
              CLI entry point for DirScribe. Parses command-line arguments
              and prints or writes the directory structure.
              """
              parser = argparse.ArgumentParser(
                  description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
              )
              parser.add_argument("directory", type=str, help="Path to the directory to scan.")
              parser.add_argument(
                  "-e", "--extensions", nargs="*", default=[],
                  help=(
                      "List of file extensions to include content for (e.g. -e .py .txt). "
                      "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
                  )
              )
              parser.add_argument(
                  "--skip-hidden", action="store_true",
                  help="Skip hidden files and directories."
              )
              parser.add_argument(
                  "--max-size", type=int, default=None,
                  help="Maximum file size (in bytes) to read. Larger files will be skipped."
              )
              parser.add_argument(
                  "--show-metadata", action="store_true",
                  help="Include file metadata (size, modified time) in the output."
              )
              parser.add_argument(
                  "--detect-language", action="store_true",
                  help="Attach a 'language' field based on file extension."
              )
              parser.add_argument(
                  "--output-format", choices=["text", "json"], default="text",
                  help="Choose output format: 'text' or 'json'. Default is 'text'."
              )
              parser.add_argument(
                  "--output-file", type=str, default=None,
                  help="If specified, write the output to this file instead of stdout."
              )
              parser.add_argument(
                  "--clip", action="store_true",
                  help="Copy the output to the clipboard (requires pyperclip)."
              )
          
              args = parser.parse_args()
              directory = Path(args.directory).resolve()
          
              # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
              use_all_extensions = False
              if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
                  use_all_extensions = True
          
              if use_all_extensions:
                  include_exts = None  # None means "include all file contents"
              else:
                  include_exts = args.extensions
          
              output_file = Path(args.output_file).resolve() if args.output_file else None
          
              result = export_directory_structure(
                  target_dir=directory,
                  include_extensions=include_exts,
                  skip_hidden=args.skip_hidden,
                  max_size=args.max_size,
                  show_metadata=args.show_metadata,
                  detect_language=args.detect_language,
                  output_format=args.output_format,
                  output_file=output_file
              )
          
              # If clipboard copy is requested
              if args.clip:
                  if pyperclip is None:
                      print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
                  else:
                      if args.output_format == "text":
                          if isinstance(result, list):
                              text_output = "\n".join(result)
                          else:
                              # If an output file was specified, result might be []
                              text_output = "\n".join(result) if result else ""
                          pyperclip.copy(text_output)
                      else:
                          # JSON output is a string unless we wrote to a file (then it might be empty)
                          json_output = result if isinstance(result, str) else ""
                          pyperclip.copy(json_output)
          
              # If no output file is specified, print to stdout
              if not output_file:
                  if args.output_format == "text":
                      for line in result:  # type: ignore
                          print(line)
                  else:
                      print(result)  # type: ignore
          
          
          def _read_file_content(file_path: Path) -> str:
              """
              Safely reads text content from the specified file using UTF-8 with error replacement.
              """
              try:
                  return file_path.read_text(encoding="utf-8", errors="replace")
              except Exception as e:
                  return f"<<Error reading file: {e}>>"
          
          
          def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
              """
              Retrieves basic metadata: file size in bytes and last modified time in ISO format.
              """
              size = file_path.stat().st_size
              mtime = file_path.stat().st_mtime
              modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
              return {
                  "size": size,
                  "modified": modified_iso
              }
          
          
          if __name__ == "__main__":
              main()
  üìÑ CHANGELOG.md
    # Changelog
    
    All notable changes to this project will be documented here.
    
    ## [0.1.0] - 2025-01-19
    ### Added
    - Initial release of DirScribe
    - Recursive directory scanning
    - Optional file-content inclusion via extensions
  üìÑ CODE_OF_CONDUCT.md
    # Contributor Covenant Code of Conduct
    
    ## Our Pledge
    
    We as members, contributors, and leaders pledge to make participation in our
    community a harassment-free experience for everyone, regardless of age, body size,
    disability, ethnicity, gender identity and expression, level of experience,
    nationality, personal appearance, race, religion, or sexual identity and orientation.
    
    We pledge to act and interact in ways that contribute to an open, welcoming,
    diverse, inclusive, and healthy community.
    
    ## Our Standards
    
    Examples of behavior that contributes to a positive environment:
    - Using welcoming and inclusive language
    - Being respectful of differing viewpoints and experiences
    - Gracefully accepting constructive criticism
    - Focusing on what is best for the community
    
    Examples of unacceptable behavior:
    - The use of sexualized language or imagery, and unwelcome sexual attention
    - Insults or personal attacks
    - Harassment in any form
    - Other conduct which could reasonably be considered inappropriate in a professional setting
    
    ## Enforcement
    
    Instances of abusive, harassing, or otherwise unacceptable behavior may be reported
    by contacting the project team. All complaints will be reviewed and investigated 
    and will result in a response deemed necessary and appropriate to the circumstances.
  üìÑ CONTRIBUTING.md
    # Contributing to DirScribe
    
    Thank you for your interest in contributing to DirScribe! This document explains how to submit pull requests (PRs), report issues, and follow best practices for a smooth contribution process.
    
    ## Development Setup
    
    1. **Fork** the repository on GitHub, then clone it locally.
    2. Create a feature branch:
       ```bash
       git checkout -b feature/my-awesome-feature
       ```
    3. Install and test the package:
       ```bash
       pip install -e .[dev]
       pytest
       ```
    
    ## Coding Style
    
    * Adhere to PEP 8 for Python code style whenever possible.
    * Write clear docstrings or comments to help others understand your code.
    
    ## Commit Messages
    
    * Keep commit messages concise but descriptive.
    * Make incremental commits that each address a single topic or issue if possible.
    
    ## Pull Requests
    
    1. Verify that all tests pass and your changes are documented.
    2. Open a PR against the `main` branch with a clear title and description.
    3. In the PR body, describe what changes you made and why. Include any relevant issue numbers.
    4. Be prepared to address review feedback; update your branch with additional commits as needed.
    
    ## Issue Reporting
    
    * Use GitHub Issues for bug reports, feature requests, or questions.
    * Provide as much detail as possible, including steps to reproduce bugs if applicable.
    
    ## License
    
    * DirScribe is distributed under the MIT License.
    * Any contributions you make will also fall under that same license.
    
    Thank you for your contributions and support!
  üìÅ dirscribe/
    üìÑ __init__.py
      """
      DirScribe
      
      A Python package that helps you export a directory structure and optionally
      the contents of files with certain extensions.
      """
      
      __version__ = "0.1.1"
      
      from .core import export_directory_structure, main
    üìÅ __pycache__/
      üìÑ __init__.cpython-310.pyc
      üìÑ __init__.cpython-39.pyc
      üìÑ core.cpython-310.pyc
      üìÑ core.cpython-39.pyc
    üìÑ core.py
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      
      import argparse
      import json
      import time
      import sys
      from pathlib import Path
      from typing import List, Optional, Union, Dict, Any
      
      try:
          import pyperclip
      except ImportError:
          pyperclip = None
      
      #: A default dictionary for mapping file extensions to language names.
      LANGUAGE_MAP = {
          ".py": "Python",
          ".js": "JavaScript",
          ".ts": "TypeScript",
          ".java": "Java",
          ".rb": "Ruby",
          ".php": "PHP",
          ".html": "HTML",
          ".css": "CSS",
          ".cpp": "C++",
          ".c": "C",
          ".go": "Go",
          ".rs": "Rust",
          ".swift": "Swift",
      }
      
      
      def scan_directory(
          target_dir: Path,
          include_extensions: Optional[List[str]] = None,
          skip_hidden: bool = False,
          max_size: Optional[int] = None,
          show_metadata: bool = False,
          detect_language: bool = False
      ) -> Dict[str, Any]:
          """
          Recursively scans the target directory and builds a nested dictionary
          representing directories and files. File contents are included only for
          certain extensions if specified.
      
          Args:
              target_dir (Path):
                  The directory path to scan.
              include_extensions (List[str], optional):
                  A list of file extensions to include content for. If None, all files are included.
                  If an empty list, no file content is included.
              skip_hidden (bool):
                  If True, hidden files and directories (names starting with '.') are skipped.
              max_size (int, optional):
                  Maximum file size in bytes to read. Files larger than this are skipped.
              show_metadata (bool):
                  If True, file metadata (size, modified time) is included in the output.
              detect_language (bool):
                  If True, a "language" field is added to each file based on extension.
      
          Returns:
              Dict[str, Any]: A nested dictionary describing the directory structure.
          """
          if not target_dir.exists():
              return {
                  "type": "error",
                  "message": f"Directory does not exist: {target_dir}"
              }
      
          tree = {
              "type": "directory",
              "name": target_dir.name,
              "path": str(target_dir.resolve()),
              "children": []
          }
      
          try:
              entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
          except PermissionError:
              tree["children"].append({
                  "type": "error",
                  "message": f"Permission denied: {target_dir}"
              })
              return tree
      
          for entry in entries:
              # Skip hidden files/directories if skip_hidden == True
              if skip_hidden and entry.name.startswith('.'):
                  continue
      
              if entry.is_dir():
                  subtree = scan_directory(
                      entry,
                      include_extensions=include_extensions,
                      skip_hidden=skip_hidden,
                      max_size=max_size,
                      show_metadata=show_metadata,
                      detect_language=detect_language
                  )
                  tree["children"].append(subtree)
              else:
                  file_node = {
                      "type": "file",
                      "name": entry.name,
                      "path": str(entry.resolve())
                  }
      
                  # Detect language if requested
                  if detect_language:
                      lang = LANGUAGE_MAP.get(entry.suffix.lower())
                      if lang:
                          file_node["language"] = lang
      
                  # Show metadata if requested
                  if show_metadata:
                      file_node["metadata"] = _get_file_metadata(entry)
      
                  # Decide if we include the file content
                  if include_extensions and len(include_extensions) > 0:
                      # If we put "ALL_MODE" into include_extensions, treat as "include all"
                      if "ALL_MODE" in include_extensions:
                          should_include = True
                      else:
                          should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                  elif include_extensions is None:
                      # If include_extensions is None, treat as "include all"
                      should_include = True
                  else:
                      # If it's an empty list, do not include file content
                      should_include = False
      
                  if should_include:
                      size = entry.stat().st_size
                      if max_size is not None and size > max_size:
                          file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                      else:
                          file_node["content"] = _read_file_content(entry)
      
                  tree["children"].append(file_node)
      
          return tree
      
      
      def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
          """
          Builds a list of text lines (ASCII tree style) from the nested dictionary.
      
          Args:
              tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
              indent_level (int): Internal parameter for managing indentation in recursion.
      
          Returns:
              List[str]: A list of text lines representing the directory tree and optional contents.
          """
          lines = []
      
          node_type = tree.get("type")
          node_name = tree.get("name", "unknown")
      
          if node_type == "error":
              msg = tree.get("message", "Unknown error")
              lines.append("  " * indent_level + f"[Error] {msg}")
              return lines
      
          if node_type == "directory":
              lines.append("  " * indent_level + f"üìÅ {node_name}/")
              children = tree.get("children", [])
              for child in children:
                  lines.extend(build_text_output(child, indent_level + 1))
      
          elif node_type == "file":
              language = tree.get("language")
              if language:
                  lines.append("  " * indent_level + f"üìÑ {node_name} ({language})")
              else:
                  lines.append("  " * indent_level + f"üìÑ {node_name}")
      
              content = tree.get("content")
              if content is not None:
                  for c_line in content.splitlines():
                      lines.append("  " * (indent_level + 1) + c_line)
      
              metadata = tree.get("metadata")
              if metadata:
                  lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                  lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
      
          return lines
      
      
      def export_directory_structure(
          target_dir: Path,
          include_extensions: Optional[List[str]] = None,
          skip_hidden: bool = False,
          max_size: Optional[int] = None,
          show_metadata: bool = False,
          detect_language: bool = False,
          output_format: str = "text",
          output_file: Optional[Path] = None
      ) -> Union[List[str], str]:
          """
          Scans the directory and produces output in either text or JSON format.
          Optionally writes the result to a file if output_file is specified.
      
          Args:
              target_dir (Path): The directory to scan.
              include_extensions (List[str], optional): File extensions to include contents for.
                  If None, includes all. If empty, includes none.
              skip_hidden (bool): Whether to skip hidden files/directories.
              max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
              show_metadata (bool): Whether to include file metadata in the output.
              detect_language (bool): Whether to add a 'language' field based on file extension.
              output_format (str): 'text' or 'json'. Default is 'text'.
              output_file (Path, optional): If specified, the output is written to this file.
      
          Returns:
              Union[List[str], str]:
                  - If output_format='text' and output_file is None, returns a list of lines.
                  - If output_format='json' and output_file is None, returns a JSON string.
                  - If output_file is specified, writes to file and returns an empty list or string.
          """
          tree = scan_directory(
              target_dir=target_dir,
              include_extensions=include_extensions,
              skip_hidden=skip_hidden,
              max_size=max_size,
              show_metadata=show_metadata,
              detect_language=detect_language
          )
      
          if output_format not in ["text", "json"]:
              raise ValueError("Invalid output format. Choose 'text' or 'json'.")
      
          if output_format == "text":
              output_data = build_text_output(tree)
          else:
              output_data = json.dumps(tree, indent=2)
      
          if output_file is not None:
              if output_format == "text":
                  # output_data is a list of strings
                  text_content = "\n".join(output_data)
                  output_file.write_text(text_content, encoding="utf-8")
                  return []
              else:
                  # output_data is a JSON string
                  output_file.write_text(output_data, encoding="utf-8")
                  return ""
          else:
              return output_data
      
      
      def main():
          """
          CLI entry point for DirScribe. Parses command-line arguments
          and prints or writes the directory structure.
          """
          parser = argparse.ArgumentParser(
              description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
          )
          parser.add_argument("directory", type=str, help="Path to the directory to scan.")
          parser.add_argument(
              "-e", "--extensions", nargs="*", default=[],
              help=(
                  "List of file extensions to include content for (e.g. -e .py .txt). "
                  "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
              )
          )
          parser.add_argument(
              "--skip-hidden", action="store_true",
              help="Skip hidden files and directories."
          )
          parser.add_argument(
              "--max-size", type=int, default=None,
              help="Maximum file size (in bytes) to read. Larger files will be skipped."
          )
          parser.add_argument(
              "--show-metadata", action="store_true",
              help="Include file metadata (size, modified time) in the output."
          )
          parser.add_argument(
              "--detect-language", action="store_true",
              help="Attach a 'language' field based on file extension."
          )
          parser.add_argument(
              "--output-format", choices=["text", "json"], default="text",
              help="Choose output format: 'text' or 'json'. Default is 'text'."
          )
          parser.add_argument(
              "--output-file", type=str, default=None,
              help="If specified, write the output to this file instead of stdout."
          )
          parser.add_argument(
              "--clip", action="store_true",
              help="Copy the output to the clipboard (requires pyperclip)."
          )
      
          args = parser.parse_args()
          directory = Path(args.directory).resolve()
      
          # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
          use_all_extensions = False
          if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
              use_all_extensions = True
      
          if use_all_extensions:
              include_exts = None  # None means "include all file contents"
          else:
              include_exts = args.extensions
      
          output_file = Path(args.output_file).resolve() if args.output_file else None
      
          result = export_directory_structure(
              target_dir=directory,
              include_extensions=include_exts,
              skip_hidden=args.skip_hidden,
              max_size=args.max_size,
              show_metadata=args.show_metadata,
              detect_language=args.detect_language,
              output_format=args.output_format,
              output_file=output_file
          )
      
          # If clipboard copy is requested
          if args.clip:
              if pyperclip is None:
                  print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
              else:
                  if args.output_format == "text":
                      if isinstance(result, list):
                          text_output = "\n".join(result)
                      else:
                          # If an output file was specified, result might be []
                          text_output = "\n".join(result) if result else ""
                      pyperclip.copy(text_output)
                  else:
                      # JSON output is a string unless we wrote to a file (then it might be empty)
                      json_output = result if isinstance(result, str) else ""
                      pyperclip.copy(json_output)
      
          # If no output file is specified, print to stdout
          if not output_file:
              if args.output_format == "text":
                  for line in result:  # type: ignore
                      print(line)
              else:
                  print(result)  # type: ignore
      
      
      def _read_file_content(file_path: Path) -> str:
          """
          Safely reads text content from the specified file using UTF-8 with error replacement.
          """
          try:
              return file_path.read_text(encoding="utf-8", errors="replace")
          except Exception as e:
              return f"<<Error reading file: {e}>>"
      
      
      def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
          """
          Retrieves basic metadata: file size in bytes and last modified time in ISO format.
          """
          size = file_path.stat().st_size
          mtime = file_path.stat().st_mtime
          modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
          return {
              "size": size,
              "modified": modified_iso
          }
      
      
      if __name__ == "__main__":
          main()
  üìÅ dirscribe.egg-info/
    üìÑ dependency_links.txt
      
    üìÑ entry_points.txt
      [console_scripts]
      dirscribe = dirscribe.core:main
    üìÑ PKG-INFO
    üìÑ SOURCES.txt
      CHANGELOG.md
      CODE_OF_CONDUCT.md
      CONTRIBUTING.md
      LICENSE
      MANIFEST.in
      README.md
      pyproject.toml
      setup.py
      dirscribe/__init__.py
      dirscribe/core.py
      dirscribe.egg-info/PKG-INFO
      dirscribe.egg-info/SOURCES.txt
      dirscribe.egg-info/dependency_links.txt
      dirscribe.egg-info/entry_points.txt
      dirscribe.egg-info/top_level.txt
      tests/test_basic.py
    üìÑ top_level.txt
      dirscribe
  üìÅ dist/
    üìÑ dirscribe-0.1.2-py3-none-any.whl
    üìÑ dirscribe-0.1.2.tar.gz
  üìÑ LICENSE
  üìÑ MANIFEST.in
  üìÑ pyproject.toml
  üìÑ README.md
    # DirScribe ‚Äî Explore, Document, and Share Your Directory Structures
    
    ![Version](https://img.shields.io/badge/version-0.1.2-blue.svg)
    ![License](https://img.shields.io/badge/license-MIT-green.svg)
    ![Python 3.7+](https://img.shields.io/badge/Python-3.7+-brightgreen.svg)
    ![Stars](https://img.shields.io/github/stars/kkwmr/dirscribe?style=social)
    [![Total Downloads](https://pepy.tech/badge/dirscribe)](https://pepy.tech/project/dirscribe)
    
    DirScribe is a **lightweight yet powerful** CLI tool and Python library for **exporting directory structures** in either **text** or **JSON** format. It helps you **optionally** include file contents, **detect programming languages**, skip hidden items, limit file reading by size, show metadata (size and modification time), and output results directly to your terminal or a file.
    
    > Created by: [Kazuki Kawamura](https://casp.jp) (Caspy /Ààk√¶spi/, „Åã„Åô„Å¥„Éº)  
    > **License:** [MIT License](./LICENSE)
    
    ## Quick Look
    
    One of DirScribe's key features is how easily it can include file contents by extension.  
    - If you run `dirscribe /path -e .py .txt`, it includes only `.py` and `.txt` files' contents.  
    - **If you run `dirscribe /path -e` with no arguments, it includes *all* file contents** (new in v0.1.2).  
    - If you omit `-e` entirely, no file contents are included‚Äîjust the directory tree.
    
    Another new feature in v0.1.2 is `--clip`, which copies the final output (text or JSON) to your clipboard for quick sharing.
    
    **Example**:
    ```bash
    dirscribe /path/to/your_project -e .py --clip
    ```
    
    This command shows all .py file contents (skipping other extensions) and copies the result to your clipboard.
    
    Below is a quick text-based preview if you scan a sample project:
    
    ```
    üìÅ your_project/
      üìÑ main.py (Python)
        def calculate_total(items):
            return sum(item.price for item in items)
        
        def main():
            print("Processing orders...")
      
      üìÅ templates/
        üìÑ index.html (HTML)
          <!DOCTYPE html>
          <html>
            <head><title>My App</title></head>
            <body><h1>Welcome</h1></body>
          </html>
        
        üìÑ style.css (CSS)
          body {
            margin: 0;
            padding: 20px;
            font-family: sans-serif;
          }
    ```
    
    If you prefer JSON:
    
    ```bash
    dirscribe /path/to/your_project --output-format json
    ```
    
    You get:
    
    ```json
    {
      "type": "directory",
      "name": "your_project",
      "path": "absolute/path/your_project",
      "children": [
        {
          "type": "file",
          "name": "main.py",
          "path": "...",
          "language": "Python",
          "content": "...",
          ...
        },
        ...
      ]
    }
    ```
    
    ## Table of Contents
    - Key Features
    - Why DirScribe?
    - Installation
    - Quick Start
    - Command-Line Usage
    - Python Library Usage
    - Use Cases
    - AI Tools Integration
    - Contributing
    - License
    
    ## Key Features
    
    - Text or JSON Output
      - Choose between a human-readable tree format or a structured JSON representation for advanced integrations.
    
    - File Content Inclusion
      - Display the contents of files for specific extensions (e.g., .py, .js, .txt).
      - Tip: With v0.1.2, if you add `-e` with no extensions, all file contents are included.
    
    - Language Detection
      - Show the programming language name (e.g., .py -> Python) alongside file names.
    
    - Skip Hidden
      - Omit hidden files and directories (names starting with a dot).
    
    - Maximum Size Limit
      - Automatically skip file content if a file exceeds a specified byte-size.
    
    - Metadata Display
      - Show file size and last modification timestamp in the output.
    
    - Clipboard Copy
      - Use `--clip` to copy the output directly to your clipboard (requires pyperclip).
    
    - Save to File
      - Output can be redirected to a file rather than just printing to the console.
    
    - Highly Configurable
      - Combine various options to fit your exact needs.
    
    ## Why DirScribe?
    
    - Instant Documentation
      - Quickly generate a snapshot of your codebase ‚Äì perfect for onboarding new team members or archiving project structures.
    
    - Efficient Code Reviews
      - Include file contents up to a specified size, letting you skim important files without diving deeply into each folder.
    
    - Language Insights
      - Recognize the languages used in your project at a glance.
    
    - Scriptable
      - Integrate DirScribe into CI/CD pipelines or other automated workflows to maintain updated structure maps.
    
    - Open Source & Community-Driven
      - MIT-licensed, easily extended, and continuously improved by the community.
    
    ## Installation
    
    You can install DirScribe by cloning the repository and running:
    
    ```bash
    pip install .
    ```
    
    If you're actively editing the source, you might prefer:
    
    ```bash
    pip install -e .
    ```
    
    This sets up DirScribe in "editable" mode so changes in the code take immediate effect.
    
    If DirScribe is published on PyPI in the future, you'll be able to do:
    
    ```bash
    pip install dirscribe
    ```
    
    directly.
    
    ## Quick Start
    
    Generate a text listing of a directory:
    
    ```bash
    dirscribe /path/to/project
    ```
    
    Generate a JSON output and save it to a file:
    
    ```bash
    dirscribe /path/to/project --output-format json --output-file project_structure.json
    ```
    
    Include all file contents (no matter the extension):
    
    ```bash
    dirscribe /path/to/project -e
    ```
    
    Copy the result to your clipboard (also new in 0.1.2):
    
    ```bash
    dirscribe /path/to/project --clip
    ```
    
    That's it! Mix and match the options below for your needs.
    
    ## Command-Line Usage
    
    Once installed, you can run dirscribe:
    
    ```
    dirscribe [DIRECTORY] [OPTIONS]
    ```
    
    ### Common Options
    
    - `-e, --extensions <EXT ...>`
      - Specify which file extensions to include content for (e.g., `-e .py .js`).
      - If you pass `-e` with no extensions, DirScribe will include the contents of all files.
      - If you omit `-e` entirely, it includes no file contents.
    
    - `--detect-language`
      - Enables language detection based on file extensions (e.g., .py -> Python).
    
    - `--skip-hidden`
      - Skips files and directories whose names begin with `.`.
    
    - `--max-size <BYTES>`
      - Maximum file size (in bytes) to read. Files larger than this are ignored.
    
    - `--show-metadata`
      - Displays file metadata (size in bytes, last modification time) next to file content.
    
    - `--output-format <text|json>`
      - Output either a text-based tree or JSON structure. Defaults to text.
    
    - `--output-file <FILE>`
      - Write the output to the specified file instead of printing to stdout.
    
    - `--clip`
      - Copy the final output to your clipboard (requires pyperclip).
    
    ### Example: Combine Multiple Options
    
    ```bash
    dirscribe /path/to/src \
      -e .py .html \
      --detect-language \
      --skip-hidden \
      --max-size 2000 \
      --show-metadata \
      --output-format text \
      --output-file output.txt
    ```
    
    What this does:
    1. Recursively scans `/path/to/src`
    2. Shows contents of files with .py or .html extension (up to 2000 bytes)
    3. Skips hidden items (names starting with a dot)
    4. Displays file size & last modified time
    5. Identifies language names where possible
    6. Renders as a textual tree
    7. Saves it to output.txt (instead of printing to the terminal)
    
    ## Python Library Usage
    
    DirScribe can also be used as a library:
    
    ```python
    from pathlib import Path
    from dirscribe.core import export_directory_structure
    
    def main():
        directory = Path("/path/to/src")
        
        # Export directory structure as text (list of lines)
        lines = export_directory_structure(
            target_dir=directory,
            include_extensions=[".py", ".html"],
            skip_hidden=True,
            max_size=2000,
            show_metadata=True,
            detect_language=True,
            output_format="text",
            output_file=None
        )
        
        # If output_format="text" and output_file=None, you get a list of lines
        for line in lines:
            print(line)
    
    if __name__ == "__main__":
        main()
    ```
    
    ### Parameters
    
    - `target_dir` (Path)
      - The folder you want to scan.
    
    - `include_extensions` (List[str], optional)
      - File extensions for which file contents should be included.
      - Pass None or use `-e` with no args to include all files.
    
    - `skip_hidden` (bool, default=False)
      - Skip hidden files and directories.
    
    - `max_size` (int, optional)
      - Skip content for files larger than this size.
    
    - `show_metadata` (bool, default=False)
      - Show file size and last modification time.
    
    - `detect_language` (bool, default=False)
      - Attach a language field based on file extension (e.g., .py -> Python).
    
    - `output_format` (str, default="text")
      - Either "text" or "json".
    
    - `output_file` (Path, optional)
      - If provided, the data is written to that file. Returns empty list/string.
    
    ### Return Values:
    
    - If `output_format="text"` and `output_file=None`, returns a list of text lines.
    - If `output_format="json"` and `output_file=None`, returns a JSON string.
    - If `output_file` is set, writes to that file and returns an empty list or empty string.
    
    ## Use Cases
    
    ### Instant Project Documentation
    Generate a tree-like structure of your source code, optionally with file contents.
    Great for sharing with collaborators or creating "at-a-glance" docs.
    
    ### Code Review & Auditing
    Quickly see which files exist, their languages, and read short/medium files directly.
    
    ### Security / Compliance Checks
    Skip hidden or large files, or selectively scan certain file types.
    
    ### CI/CD Integration
    Save a JSON manifest of your repository structure as part of your build artifacts.
    Compare structure between builds or track changes over time.
    
    ### Scripting / Automation
    Leverage DirScribe's JSON or text output in custom pipelines or scripts.
    
    ## AI Tools Integration
    
    DirScribe's output is perfect for feeding into ChatGPT or other AI tools to analyze or summarize a project's structure:
    
    1. Generate a text or JSON snapshot:
    ```bash
    dirscribe /path/to/src --output-format text > structure.txt
    ```
    
    2. Copy/paste structure.txt into ChatGPT (or your AI tool).
    
    3. Ask questions like:
       - "Give me an overview of this project."
       - "Identify potential security concerns."
       - "Suggest improvements or refactoring ideas."
    
    By providing AI with a precise structure (and optionally file contents), you can quickly gain insights or documentation without manual exploration.
    
    ## Contributing
    
    We welcome contributions, suggestions, and bug reports! See our CONTRIBUTING.md to learn how to propose changes or open pull requests. We also encourage you to open an issue for any problems or feature requests.
    
    Ways to help:
    - Code contributions (new features, bug fixes, refactoring)
    - Documentation improvements (clarify instructions, add examples)
    - Language mapping expansions (add more file extensions to LANGUAGE_MAP)
    - Feedback and testing on different OS environments or large-scale projects
    
    If you find DirScribe valuable, please star the repository and share it with fellow developers!
    
    ## License
    
    This project is distributed under the MIT License.
    ¬© 2025 Kazuki Kawamura
  üìÑ requirements-dev.txt
    pytest==7.3.1
  üìÑ setup.py
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    import os
    from setuptools import setup, find_packages
    
    
    this_directory = os.path.abspath(os.path.dirname(__file__))
    with open(os.path.join(this_directory, "README.md"), encoding="utf-8") as f:
        long_description = f.read()
    
    setup(
        name="dirscribe",
        version="0.1.2",
        description="A tool to export directory structure and optionally include file contents for selected extensions.",
        long_description=long_description,
        long_description_content_type="text/markdown", 
        author="Kazuki Kawamura",
        url="https://github.com/kkwmr/dirscribe",
        packages=find_packages(),
        python_requires=">=3.7",
        entry_points={
            "console_scripts": [
                "dirscribe=dirscribe.core:main"
            ]
        },
        classifiers=[
            "Programming Language :: Python :: 3",
            "License :: OSI Approved :: MIT License",
            "Operating System :: OS Independent"
        ],
        license="MIT"
    )
  üìÑ test.txt
    üìÅ dirscribe/
      üìÅ .git/
        üìÅ branches/
        üìÑ COMMIT_EDITMSG
        üìÑ config
        üìÑ description
        üìÑ HEAD
        üìÅ hooks/
          üìÑ applypatch-msg.sample
          üìÑ commit-msg.sample
          üìÑ fsmonitor-watchman.sample
          üìÑ post-update.sample
          üìÑ pre-applypatch.sample
          üìÑ pre-commit.sample
          üìÑ pre-merge-commit.sample
          üìÑ pre-push.sample
          üìÑ pre-rebase.sample
          üìÑ pre-receive.sample
          üìÑ prepare-commit-msg.sample
          üìÑ update.sample
        üìÑ index
        üìÅ info/
          üìÑ exclude
        üìÅ logs/
          üìÑ HEAD
          üìÅ refs/
            üìÅ heads/
              üìÑ main
            üìÅ remotes/
              üìÅ origin/
                üìÑ main
        üìÅ objects/
          üìÅ 0e/
            üìÑ 7b24d3c34ff1d4f57029e12a0ed9a447afc2e1
          üìÅ 18/
            üìÑ 0791f3b9750e562dd96939752106089b678e2b
          üìÅ 19/
            üìÑ 1099e8aa4bc3b49c9f10485f3c83a258acb36b
          üìÅ 1b/
            üìÑ ae5d2e49942d13594c6f3aa2ea29915adf7b37
          üìÅ 36/
            üìÑ a73a7afd60aa9f24af32c3fccc8ec2f7f39fed
          üìÅ 3b/
            üìÑ 94d9b6343d903a398527621d433e935b852607
          üìÅ 44/
            üìÑ 54c8b82a45039e7129ba452368536bf60268ae
          üìÅ 4d/
            üìÑ 173a646bbdf257211ae246a798dff4724e7f51
          üìÅ 54/
            üìÑ 02ad3b254c098c7fe5074501f5fbddfe1bc25c
          üìÅ 55/
            üìÑ abe6269ff8a230d10ae9d88f3a45f73998026c
          üìÅ 5f/
            üìÑ 73c6ac039b84b5835e2ad4323a6cf9087ca84c
          üìÅ 60/
            üìÑ 3d4f67046cbfb5452df33959b64995d8f848a4
          üìÅ 61/
            üìÑ 9c23f76d0be9c213f69f54b83d925f53d85792
          üìÅ 71/
            üìÑ 77ec5c59c262e95e9d3e29f9900d640eb1209b
          üìÅ 72/
            üìÑ a99349f92ad6cdf65b86bcbc17e0115b0052c1
          üìÅ 7e/
            üìÑ b8a4a6807e48be35fdf1f129907e75229bf495
          üìÅ 8a/
            üìÑ 224a9eb9417670b1ca1a82b17f81b80651eb5b
          üìÅ 97/
            üìÑ 87c3bdf008a57ae3cb2e27a8261eb3f134ff73
          üìÅ a5/
            üìÑ b8b5610c39736debb58063a66d941589b31c01
          üìÅ a9/
            üìÑ 4546d944b15cdcb850afefd6575a1def7d9462
          üìÅ b8/
            üìÑ 0111c16d345d531c50507f3301a30437eff486
          üìÅ bf/
            üìÑ c68f8759cfb2bc629a1dab54353f0c61a41334
          üìÅ c4/
            üìÑ d04a08d024e901bb246cc8da9ccf6b49b31909
          üìÅ ca/
            üìÑ 1a7e5856f6d86106b40128981418e08b71627b
          üìÅ d5/
            üìÑ 3f8116ec79e4e38df364ca416ec71fc908ba19
          üìÅ d9/
            üìÑ 8dc5e36cf0c651f2b0bc0702d6fa5f339eba09
          üìÅ e0/
            üìÑ 35be5e92bb7fb071ed5bf616b35c8d449b61f3
          üìÅ f6/
            üìÑ c100e6d7b8539053c2afec43081ab07715f2ea
          üìÅ fb/
            üìÑ 96d0eb93178eaabf8967073e8a2a6d0b8b03a6
            üìÑ fd31beab538a41c3d047db65f569f8dac09885
          üìÅ info/
          üìÅ pack/
        üìÅ refs/
          üìÅ heads/
            üìÑ main
          üìÅ remotes/
            üìÅ origin/
              üìÑ main
          üìÅ tags/
            üìÑ v0.1.0
            üìÑ v0.1.1
      üìÑ .gitignore
      üìÅ .pytest_cache/
        üìÑ .gitignore
        üìÑ CACHEDIR.TAG
        üìÑ README.md
        üìÅ v/
          üìÅ cache/
            üìÑ lastfailed
            üìÑ nodeids
            üìÑ stepwise
      üìÅ build/
        üìÅ bdist.linux-x86_64/
        üìÅ lib/
          üìÅ dirscribe/
            üìÑ __init__.py
              """
              DirScribe
              
              A Python package that helps you export a directory structure and optionally
              the contents of files with certain extensions.
              """
              
              __version__ = "0.1.1"
              
              from .core import export_directory_structure, main
            üìÑ core.py
              #!/usr/bin/env python3
              # -*- coding: utf-8 -*-
              
              import argparse
              import json
              import time
              import sys
              from pathlib import Path
              from typing import List, Optional, Union, Dict, Any
              
              try:
                  import pyperclip
              except ImportError:
                  pyperclip = None
              
              #: A default dictionary for mapping file extensions to language names.
              LANGUAGE_MAP = {
                  ".py": "Python",
                  ".js": "JavaScript",
                  ".ts": "TypeScript",
                  ".java": "Java",
                  ".rb": "Ruby",
                  ".php": "PHP",
                  ".html": "HTML",
                  ".css": "CSS",
                  ".cpp": "C++",
                  ".c": "C",
                  ".go": "Go",
                  ".rs": "Rust",
                  ".swift": "Swift",
              }
              
              
              def scan_directory(
                  target_dir: Path,
                  include_extensions: Optional[List[str]] = None,
                  skip_hidden: bool = False,
                  max_size: Optional[int] = None,
                  show_metadata: bool = False,
                  detect_language: bool = False
              ) -> Dict[str, Any]:
                  """
                  Recursively scans the target directory and builds a nested dictionary
                  representing directories and files. File contents are included only for
                  certain extensions if specified.
              
                  Args:
                      target_dir (Path):
                          The directory path to scan.
                      include_extensions (List[str], optional):
                          A list of file extensions to include content for. If None, all files are included.
                          If an empty list, no file content is included.
                      skip_hidden (bool):
                          If True, hidden files and directories (names starting with '.') are skipped.
                      max_size (int, optional):
                          Maximum file size in bytes to read. Files larger than this are skipped.
                      show_metadata (bool):
                          If True, file metadata (size, modified time) is included in the output.
                      detect_language (bool):
                          If True, a "language" field is added to each file based on extension.
              
                  Returns:
                      Dict[str, Any]: A nested dictionary describing the directory structure.
                  """
                  if not target_dir.exists():
                      return {
                          "type": "error",
                          "message": f"Directory does not exist: {target_dir}"
                      }
              
                  tree = {
                      "type": "directory",
                      "name": target_dir.name,
                      "path": str(target_dir.resolve()),
                      "children": []
                  }
              
                  try:
                      entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
                  except PermissionError:
                      tree["children"].append({
                          "type": "error",
                          "message": f"Permission denied: {target_dir}"
                      })
                      return tree
              
                  for entry in entries:
                      # Skip hidden files/directories if skip_hidden == True
                      if skip_hidden and entry.name.startswith('.'):
                          continue
              
                      if entry.is_dir():
                          subtree = scan_directory(
                              entry,
                              include_extensions=include_extensions,
                              skip_hidden=skip_hidden,
                              max_size=max_size,
                              show_metadata=show_metadata,
                              detect_language=detect_language
                          )
                          tree["children"].append(subtree)
                      else:
                          file_node = {
                              "type": "file",
                              "name": entry.name,
                              "path": str(entry.resolve())
                          }
              
                          # Detect language if requested
                          if detect_language:
                              lang = LANGUAGE_MAP.get(entry.suffix.lower())
                              if lang:
                                  file_node["language"] = lang
              
                          # Show metadata if requested
                          if show_metadata:
                              file_node["metadata"] = _get_file_metadata(entry)
              
                          # Decide if we include the file content
                          if include_extensions and len(include_extensions) > 0:
                              # If we put "ALL_MODE" into include_extensions, treat as "include all"
                              if "ALL_MODE" in include_extensions:
                                  should_include = True
                              else:
                                  should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                          elif include_extensions is None:
                              # If include_extensions is None, treat as "include all"
                              should_include = True
                          else:
                              # If it's an empty list, do not include file content
                              should_include = False
              
                          if should_include:
                              size = entry.stat().st_size
                              if max_size is not None and size > max_size:
                                  file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                              else:
                                  file_node["content"] = _read_file_content(entry)
              
                          tree["children"].append(file_node)
              
                  return tree
              
              
              def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
                  """
                  Builds a list of text lines (ASCII tree style) from the nested dictionary.
              
                  Args:
                      tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
                      indent_level (int): Internal parameter for managing indentation in recursion.
              
                  Returns:
                      List[str]: A list of text lines representing the directory tree and optional contents.
                  """
                  lines = []
              
                  node_type = tree.get("type")
                  node_name = tree.get("name", "unknown")
              
                  if node_type == "error":
                      msg = tree.get("message", "Unknown error")
                      lines.append("  " * indent_level + f"[Error] {msg}")
                      return lines
              
                  if node_type == "directory":
                      lines.append("  " * indent_level + f"üìÅ {node_name}/")
                      children = tree.get("children", [])
                      for child in children:
                          lines.extend(build_text_output(child, indent_level + 1))
              
                  elif node_type == "file":
                      language = tree.get("language")
                      if language:
                          lines.append("  " * indent_level + f"üìÑ {node_name} ({language})")
                      else:
                          lines.append("  " * indent_level + f"üìÑ {node_name}")
              
                      content = tree.get("content")
                      if content is not None:
                          for c_line in content.splitlines():
                              lines.append("  " * (indent_level + 1) + c_line)
              
                      metadata = tree.get("metadata")
                      if metadata:
                          lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                          lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
              
                  return lines
              
              
              def export_directory_structure(
                  target_dir: Path,
                  include_extensions: Optional[List[str]] = None,
                  skip_hidden: bool = False,
                  max_size: Optional[int] = None,
                  show_metadata: bool = False,
                  detect_language: bool = False,
                  output_format: str = "text",
                  output_file: Optional[Path] = None
              ) -> Union[List[str], str]:
                  """
                  Scans the directory and produces output in either text or JSON format.
                  Optionally writes the result to a file if output_file is specified.
              
                  Args:
                      target_dir (Path): The directory to scan.
                      include_extensions (List[str], optional): File extensions to include contents for.
                          If None, includes all. If empty, includes none.
                      skip_hidden (bool): Whether to skip hidden files/directories.
                      max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
                      show_metadata (bool): Whether to include file metadata in the output.
                      detect_language (bool): Whether to add a 'language' field based on file extension.
                      output_format (str): 'text' or 'json'. Default is 'text'.
                      output_file (Path, optional): If specified, the output is written to this file.
              
                  Returns:
                      Union[List[str], str]:
                          - If output_format='text' and output_file is None, returns a list of lines.
                          - If output_format='json' and output_file is None, returns a JSON string.
                          - If output_file is specified, writes to file and returns an empty list or string.
                  """
                  tree = scan_directory(
                      target_dir=target_dir,
                      include_extensions=include_extensions,
                      skip_hidden=skip_hidden,
                      max_size=max_size,
                      show_metadata=show_metadata,
                      detect_language=detect_language
                  )
              
                  if output_format not in ["text", "json"]:
                      raise ValueError("Invalid output format. Choose 'text' or 'json'.")
              
                  if output_format == "text":
                      output_data = build_text_output(tree)
                  else:
                      output_data = json.dumps(tree, indent=2)
              
                  if output_file is not None:
                      if output_format == "text":
                          # output_data is a list of strings
                          text_content = "\n".join(output_data)
                          output_file.write_text(text_content, encoding="utf-8")
                          return []
                      else:
                          # output_data is a JSON string
                          output_file.write_text(output_data, encoding="utf-8")
                          return ""
                  else:
                      return output_data
              
              
              def main():
                  """
                  CLI entry point for DirScribe. Parses command-line arguments
                  and prints or writes the directory structure.
                  """
                  parser = argparse.ArgumentParser(
                      description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
                  )
                  parser.add_argument("directory", type=str, help="Path to the directory to scan.")
                  parser.add_argument(
                      "-e", "--extensions", nargs="*", default=[],
                      help=(
                          "List of file extensions to include content for (e.g. -e .py .txt). "
                          "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
                      )
                  )
                  parser.add_argument(
                      "--skip-hidden", action="store_true",
                      help="Skip hidden files and directories."
                  )
                  parser.add_argument(
                      "--max-size", type=int, default=None,
                      help="Maximum file size (in bytes) to read. Larger files will be skipped."
                  )
                  parser.add_argument(
                      "--show-metadata", action="store_true",
                      help="Include file metadata (size, modified time) in the output."
                  )
                  parser.add_argument(
                      "--detect-language", action="store_true",
                      help="Attach a 'language' field based on file extension."
                  )
                  parser.add_argument(
                      "--output-format", choices=["text", "json"], default="text",
                      help="Choose output format: 'text' or 'json'. Default is 'text'."
                  )
                  parser.add_argument(
                      "--output-file", type=str, default=None,
                      help="If specified, write the output to this file instead of stdout."
                  )
                  parser.add_argument(
                      "--clip", action="store_true",
                      help="Copy the output to the clipboard (requires pyperclip)."
                  )
              
                  args = parser.parse_args()
                  directory = Path(args.directory).resolve()
              
                  # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
                  use_all_extensions = False
                  if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
                      use_all_extensions = True
              
                  if use_all_extensions:
                      include_exts = None  # None means "include all file contents"
                  else:
                      include_exts = args.extensions
              
                  output_file = Path(args.output_file).resolve() if args.output_file else None
              
                  result = export_directory_structure(
                      target_dir=directory,
                      include_extensions=include_exts,
                      skip_hidden=args.skip_hidden,
                      max_size=args.max_size,
                      show_metadata=args.show_metadata,
                      detect_language=args.detect_language,
                      output_format=args.output_format,
                      output_file=output_file
                  )
              
                  # If clipboard copy is requested
                  if args.clip:
                      if pyperclip is None:
                          print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
                      else:
                          if args.output_format == "text":
                              if isinstance(result, list):
                                  text_output = "\n".join(result)
                              else:
                                  # If an output file was specified, result might be []
                                  text_output = "\n".join(result) if result else ""
                              pyperclip.copy(text_output)
                          else:
                              # JSON output is a string unless we wrote to a file (then it might be empty)
                              json_output = result if isinstance(result, str) else ""
                              pyperclip.copy(json_output)
              
                  # If no output file is specified, print to stdout
                  if not output_file:
                      if args.output_format == "text":
                          for line in result:  # type: ignore
                              print(line)
                      else:
                          print(result)  # type: ignore
              
              
              def _read_file_content(file_path: Path) -> str:
                  """
                  Safely reads text content from the specified file using UTF-8 with error replacement.
                  """
                  try:
                      return file_path.read_text(encoding="utf-8", errors="replace")
                  except Exception as e:
                      return f"<<Error reading file: {e}>>"
              
              
              def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
                  """
                  Retrieves basic metadata: file size in bytes and last modified time in ISO format.
                  """
                  size = file_path.stat().st_size
                  mtime = file_path.stat().st_mtime
                  modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
                  return {
                      "size": size,
                      "modified": modified_iso
                  }
              
              
              if __name__ == "__main__":
                  main()
      üìÑ CHANGELOG.md
      üìÑ CODE_OF_CONDUCT.md
      üìÑ CONTRIBUTING.md
      üìÅ dirscribe/
        üìÑ __init__.py
          """
          DirScribe
          
          A Python package that helps you export a directory structure and optionally
          the contents of files with certain extensions.
          """
          
          __version__ = "0.1.1"
          
          from .core import export_directory_structure, main
        üìÅ __pycache__/
          üìÑ __init__.cpython-310.pyc
          üìÑ __init__.cpython-39.pyc
          üìÑ core.cpython-310.pyc
          üìÑ core.cpython-39.pyc
        üìÑ core.py
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          
          import argparse
          import json
          import time
          import sys
          from pathlib import Path
          from typing import List, Optional, Union, Dict, Any
          
          try:
              import pyperclip
          except ImportError:
              pyperclip = None
          
          #: A default dictionary for mapping file extensions to language names.
          LANGUAGE_MAP = {
              ".py": "Python",
              ".js": "JavaScript",
              ".ts": "TypeScript",
              ".java": "Java",
              ".rb": "Ruby",
              ".php": "PHP",
              ".html": "HTML",
              ".css": "CSS",
              ".cpp": "C++",
              ".c": "C",
              ".go": "Go",
              ".rs": "Rust",
              ".swift": "Swift",
          }
          
          
          def scan_directory(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False
          ) -> Dict[str, Any]:
              """
              Recursively scans the target directory and builds a nested dictionary
              representing directories and files. File contents are included only for
              certain extensions if specified.
          
              Args:
                  target_dir (Path):
                      The directory path to scan.
                  include_extensions (List[str], optional):
                      A list of file extensions to include content for. If None, all files are included.
                      If an empty list, no file content is included.
                  skip_hidden (bool):
                      If True, hidden files and directories (names starting with '.') are skipped.
                  max_size (int, optional):
                      Maximum file size in bytes to read. Files larger than this are skipped.
                  show_metadata (bool):
                      If True, file metadata (size, modified time) is included in the output.
                  detect_language (bool):
                      If True, a "language" field is added to each file based on extension.
          
              Returns:
                  Dict[str, Any]: A nested dictionary describing the directory structure.
              """
              if not target_dir.exists():
                  return {
                      "type": "error",
                      "message": f"Directory does not exist: {target_dir}"
                  }
          
              tree = {
                  "type": "directory",
                  "name": target_dir.name,
                  "path": str(target_dir.resolve()),
                  "children": []
              }
          
              try:
                  entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
              except PermissionError:
                  tree["children"].append({
                      "type": "error",
                      "message": f"Permission denied: {target_dir}"
                  })
                  return tree
          
              for entry in entries:
                  # Skip hidden files/directories if skip_hidden == True
                  if skip_hidden and entry.name.startswith('.'):
                      continue
          
                  if entry.is_dir():
                      subtree = scan_directory(
                          entry,
                          include_extensions=include_extensions,
                          skip_hidden=skip_hidden,
                          max_size=max_size,
                          show_metadata=show_metadata,
                          detect_language=detect_language
                      )
                      tree["children"].append(subtree)
                  else:
                      file_node = {
                          "type": "file",
                          "name": entry.name,
                          "path": str(entry.resolve())
                      }
          
                      # Detect language if requested
                      if detect_language:
                          lang = LANGUAGE_MAP.get(entry.suffix.lower())
                          if lang:
                              file_node["language"] = lang
          
                      # Show metadata if requested
                      if show_metadata:
                          file_node["metadata"] = _get_file_metadata(entry)
          
                      # Decide if we include the file content
                      if include_extensions and len(include_extensions) > 0:
                          # If we put "ALL_MODE" into include_extensions, treat as "include all"
                          if "ALL_MODE" in include_extensions:
                              should_include = True
                          else:
                              should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                      elif include_extensions is None:
                          # If include_extensions is None, treat as "include all"
                          should_include = True
                      else:
                          # If it's an empty list, do not include file content
                          should_include = False
          
                      if should_include:
                          size = entry.stat().st_size
                          if max_size is not None and size > max_size:
                              file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                          else:
                              file_node["content"] = _read_file_content(entry)
          
                      tree["children"].append(file_node)
          
              return tree
          
          
          def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
              """
              Builds a list of text lines (ASCII tree style) from the nested dictionary.
          
              Args:
                  tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
                  indent_level (int): Internal parameter for managing indentation in recursion.
          
              Returns:
                  List[str]: A list of text lines representing the directory tree and optional contents.
              """
              lines = []
          
              node_type = tree.get("type")
              node_name = tree.get("name", "unknown")
          
              if node_type == "error":
                  msg = tree.get("message", "Unknown error")
                  lines.append("  " * indent_level + f"[Error] {msg}")
                  return lines
          
              if node_type == "directory":
                  lines.append("  " * indent_level + f"üìÅ {node_name}/")
                  children = tree.get("children", [])
                  for child in children:
                      lines.extend(build_text_output(child, indent_level + 1))
          
              elif node_type == "file":
                  language = tree.get("language")
                  if language:
                      lines.append("  " * indent_level + f"üìÑ {node_name} ({language})")
                  else:
                      lines.append("  " * indent_level + f"üìÑ {node_name}")
          
                  content = tree.get("content")
                  if content is not None:
                      for c_line in content.splitlines():
                          lines.append("  " * (indent_level + 1) + c_line)
          
                  metadata = tree.get("metadata")
                  if metadata:
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
          
              return lines
          
          
          def export_directory_structure(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False,
              output_format: str = "text",
              output_file: Optional[Path] = None
          ) -> Union[List[str], str]:
              """
              Scans the directory and produces output in either text or JSON format.
              Optionally writes the result to a file if output_file is specified.
          
              Args:
                  target_dir (Path): The directory to scan.
                  include_extensions (List[str], optional): File extensions to include contents for.
                      If None, includes all. If empty, includes none.
                  skip_hidden (bool): Whether to skip hidden files/directories.
                  max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
                  show_metadata (bool): Whether to include file metadata in the output.
                  detect_language (bool): Whether to add a 'language' field based on file extension.
                  output_format (str): 'text' or 'json'. Default is 'text'.
                  output_file (Path, optional): If specified, the output is written to this file.
          
              Returns:
                  Union[List[str], str]:
                      - If output_format='text' and output_file is None, returns a list of lines.
                      - If output_format='json' and output_file is None, returns a JSON string.
                      - If output_file is specified, writes to file and returns an empty list or string.
              """
              tree = scan_directory(
                  target_dir=target_dir,
                  include_extensions=include_extensions,
                  skip_hidden=skip_hidden,
                  max_size=max_size,
                  show_metadata=show_metadata,
                  detect_language=detect_language
              )
          
              if output_format not in ["text", "json"]:
                  raise ValueError("Invalid output format. Choose 'text' or 'json'.")
          
              if output_format == "text":
                  output_data = build_text_output(tree)
              else:
                  output_data = json.dumps(tree, indent=2)
          
              if output_file is not None:
                  if output_format == "text":
                      # output_data is a list of strings
                      text_content = "\n".join(output_data)
                      output_file.write_text(text_content, encoding="utf-8")
                      return []
                  else:
                      # output_data is a JSON string
                      output_file.write_text(output_data, encoding="utf-8")
                      return ""
              else:
                  return output_data
          
          
          def main():
              """
              CLI entry point for DirScribe. Parses command-line arguments
              and prints or writes the directory structure.
              """
              parser = argparse.ArgumentParser(
                  description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
              )
              parser.add_argument("directory", type=str, help="Path to the directory to scan.")
              parser.add_argument(
                  "-e", "--extensions", nargs="*", default=[],
                  help=(
                      "List of file extensions to include content for (e.g. -e .py .txt). "
                      "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
                  )
              )
              parser.add_argument(
                  "--skip-hidden", action="store_true",
                  help="Skip hidden files and directories."
              )
              parser.add_argument(
                  "--max-size", type=int, default=None,
                  help="Maximum file size (in bytes) to read. Larger files will be skipped."
              )
              parser.add_argument(
                  "--show-metadata", action="store_true",
                  help="Include file metadata (size, modified time) in the output."
              )
              parser.add_argument(
                  "--detect-language", action="store_true",
                  help="Attach a 'language' field based on file extension."
              )
              parser.add_argument(
                  "--output-format", choices=["text", "json"], default="text",
                  help="Choose output format: 'text' or 'json'. Default is 'text'."
              )
              parser.add_argument(
                  "--output-file", type=str, default=None,
                  help="If specified, write the output to this file instead of stdout."
              )
              parser.add_argument(
                  "--clip", action="store_true",
                  help="Copy the output to the clipboard (requires pyperclip)."
              )
          
              args = parser.parse_args()
              directory = Path(args.directory).resolve()
          
              # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
              use_all_extensions = False
              if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
                  use_all_extensions = True
          
              if use_all_extensions:
                  include_exts = None  # None means "include all file contents"
              else:
                  include_exts = args.extensions
          
              output_file = Path(args.output_file).resolve() if args.output_file else None
          
              result = export_directory_structure(
                  target_dir=directory,
                  include_extensions=include_exts,
                  skip_hidden=args.skip_hidden,
                  max_size=args.max_size,
                  show_metadata=args.show_metadata,
                  detect_language=args.detect_language,
                  output_format=args.output_format,
                  output_file=output_file
              )
          
              # If clipboard copy is requested
              if args.clip:
                  if pyperclip is None:
                      print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
                  else:
                      if args.output_format == "text":
                          if isinstance(result, list):
                              text_output = "\n".join(result)
                          else:
                              # If an output file was specified, result might be []
                              text_output = "\n".join(result) if result else ""
                          pyperclip.copy(text_output)
                      else:
                          # JSON output is a string unless we wrote to a file (then it might be empty)
                          json_output = result if isinstance(result, str) else ""
                          pyperclip.copy(json_output)
          
              # If no output file is specified, print to stdout
              if not output_file:
                  if args.output_format == "text":
                      for line in result:  # type: ignore
                          print(line)
                  else:
                      print(result)  # type: ignore
          
          
          def _read_file_content(file_path: Path) -> str:
              """
              Safely reads text content from the specified file using UTF-8 with error replacement.
              """
              try:
                  return file_path.read_text(encoding="utf-8", errors="replace")
              except Exception as e:
                  return f"<<Error reading file: {e}>>"
          
          
          def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
              """
              Retrieves basic metadata: file size in bytes and last modified time in ISO format.
              """
              size = file_path.stat().st_size
              mtime = file_path.stat().st_mtime
              modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
              return {
                  "size": size,
                  "modified": modified_iso
              }
          
          
          if __name__ == "__main__":
              main()
      üìÅ dirscribe.egg-info/
        üìÑ dependency_links.txt
        üìÑ entry_points.txt
        üìÑ PKG-INFO
        üìÑ SOURCES.txt
        üìÑ top_level.txt
      üìÅ dist/
        üìÑ dirscribe-0.1.2-py3-none-any.whl
        üìÑ dirscribe-0.1.2.tar.gz
      üìÑ LICENSE
      üìÑ MANIFEST.in
      üìÑ pyproject.toml
      üìÑ README.md
      üìÑ requirements-dev.txt
      üìÑ setup.py
        #!/usr/bin/env python3
        # -*- coding: utf-8 -*-
        
        import os
        from setuptools import setup, find_packages
        
        
        this_directory = os.path.abspath(os.path.dirname(__file__))
        with open(os.path.join(this_directory, "README.md"), encoding="utf-8") as f:
            long_description = f.read()
        
        setup(
            name="dirscribe",
            version="0.1.2",
            description="A tool to export directory structure and optionally include file contents for selected extensions.",
            long_description=long_description,
            long_description_content_type="text/markdown", 
            author="Kazuki Kawamura",
            url="https://github.com/kkwmr/dirscribe",
            packages=find_packages(),
            python_requires=">=3.7",
            entry_points={
                "console_scripts": [
                    "dirscribe=dirscribe.core:main"
                ]
            },
            classifiers=[
                "Programming Language :: Python :: 3",
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent"
            ],
            license="MIT"
        )
      üìÑ test.txt
      üìÅ tests/
        üìÅ __pycache__/
          üìÑ test_basic.cpython-27-PYTEST.pyc
          üìÑ test_basic.cpython-310-pytest-8.3.4.pyc
        üìÑ test_basic.py
          import tempfile
          from pathlib import Path
          import pytest
          
          from dirscribe.core import (
              export_directory_structure,
              scan_directory
          )
          
          
          def test_scan_empty_directory():
              """
              Tests scanning an empty directory. The result should have no children.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  tree = scan_directory(tmp_path)
                  assert tree["type"] == "directory"
                  assert len(tree["children"]) == 0
          
          
          def test_skip_hidden():
              """
              Tests that hidden files and directories are skipped when skip_hidden=True.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  # Create a hidden file
                  hidden_file = tmp_path / ".hidden.txt"
                  hidden_file.write_text("This is hidden", encoding="utf-8")
          
                  # Create a normal file
                  visible_file = tmp_path / "visible.txt"
                  visible_file.write_text("This is visible", encoding="utf-8")
          
                  tree = scan_directory(tmp_path, skip_hidden=True)
                  # Should see only the visible file
                  children_names = [child["name"] for child in tree["children"]]
                  assert "visible.txt" in children_names
                  assert ".hidden.txt" not in children_names
          
          
          def test_max_size():
              """
              Tests that files exceeding max_size do not have their content read.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  big_file = tmp_path / "bigfile.txt"
                  # Write a large content
                  big_file.write_text("A" * 5000, encoding="utf-8")
          
                  small_file = tmp_path / "smallfile.txt"
                  small_file.write_text("Short content", encoding="utf-8")
          
                  tree = scan_directory(tmp_path, include_extensions=[".txt"], max_size=1000)
                  big_entry = next(child for child in tree["children"] if child["name"] == "bigfile.txt")
                  small_entry = next(child for child in tree["children"] if child["name"] == "smallfile.txt")
          
                  # big file content should be replaced by a skip message
                  assert "content" in big_entry
                  assert "exceeds 1000 bytes" in big_entry["content"]
                  # small file should contain actual content
                  assert small_entry["content"] == "Short content"
          
          
          def test_show_metadata():
              """
              Tests that file metadata is included when show_metadata=True.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  f = tmp_path / "example.txt"
                  f.write_text("Hello World", encoding="utf-8")
          
                  tree = scan_directory(tmp_path, include_extensions=[".txt"], show_metadata=True)
                  file_node = tree["children"][0]
                  assert "metadata" in file_node
                  assert "size" in file_node["metadata"]
                  assert file_node["metadata"]["size"] == len("Hello World")
          
          
          def test_json_output():
              """
              Tests the export_directory_structure output in JSON format.
              Ensures the returned string can be parsed as JSON.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  (tmp_path / "test.py").write_text("print('test')", encoding="utf-8")
          
                  output = export_directory_structure(
                      target_dir=tmp_path,
                      include_extensions=[".py"],
                      output_format="json"
                  )
                  import json
                  parsed = json.loads(output)
                  assert parsed["type"] == "directory"
                  assert parsed["children"][0]["name"] == "test.py"
                  assert "print('test')" in parsed["children"][0].get("content", "")
          
          
          if __name__ == "__main__":
              pytest.main([__file__])
  üìÅ tests/
    üìÅ __pycache__/
      üìÑ test_basic.cpython-27-PYTEST.pyc
      üìÑ test_basic.cpython-310-pytest-8.3.4.pyc
    üìÑ test_basic.py
      import tempfile
      from pathlib import Path
      import pytest
      
      from dirscribe.core import (
          export_directory_structure,
          scan_directory
      )
      
      
      def test_scan_empty_directory():
          """
          Tests scanning an empty directory. The result should have no children.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              tree = scan_directory(tmp_path)
              assert tree["type"] == "directory"
              assert len(tree["children"]) == 0
      
      
      def test_skip_hidden():
          """
          Tests that hidden files and directories are skipped when skip_hidden=True.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              # Create a hidden file
              hidden_file = tmp_path / ".hidden.txt"
              hidden_file.write_text("This is hidden", encoding="utf-8")
      
              # Create a normal file
              visible_file = tmp_path / "visible.txt"
              visible_file.write_text("This is visible", encoding="utf-8")
      
              tree = scan_directory(tmp_path, skip_hidden=True)
              # Should see only the visible file
              children_names = [child["name"] for child in tree["children"]]
              assert "visible.txt" in children_names
              assert ".hidden.txt" not in children_names
      
      
      def test_max_size():
          """
          Tests that files exceeding max_size do not have their content read.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              big_file = tmp_path / "bigfile.txt"
              # Write a large content
              big_file.write_text("A" * 5000, encoding="utf-8")
      
              small_file = tmp_path / "smallfile.txt"
              small_file.write_text("Short content", encoding="utf-8")
      
              tree = scan_directory(tmp_path, include_extensions=[".txt"], max_size=1000)
              big_entry = next(child for child in tree["children"] if child["name"] == "bigfile.txt")
              small_entry = next(child for child in tree["children"] if child["name"] == "smallfile.txt")
      
              # big file content should be replaced by a skip message
              assert "content" in big_entry
              assert "exceeds 1000 bytes" in big_entry["content"]
              # small file should contain actual content
              assert small_entry["content"] == "Short content"
      
      
      def test_show_metadata():
          """
          Tests that file metadata is included when show_metadata=True.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              f = tmp_path / "example.txt"
              f.write_text("Hello World", encoding="utf-8")
      
              tree = scan_directory(tmp_path, include_extensions=[".txt"], show_metadata=True)
              file_node = tree["children"][0]
              assert "metadata" in file_node
              assert "size" in file_node["metadata"]
              assert file_node["metadata"]["size"] == len("Hello World")
      
      
      def test_json_output():
          """
          Tests the export_directory_structure output in JSON format.
          Ensures the returned string can be parsed as JSON.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              (tmp_path / "test.py").write_text("print('test')", encoding="utf-8")
      
              output = export_directory_structure(
                  target_dir=tmp_path,
                  include_extensions=[".py"],
                  output_format="json"
              )
              import json
              parsed = json.loads(output)
              assert parsed["type"] == "directory"
              assert parsed["children"][0]["name"] == "test.py"
              assert "print('test')" in parsed["children"][0].get("content", "")
      
      
      if __name__ == "__main__":
          pytest.main([__file__])