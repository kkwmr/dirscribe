📁 dirscribe/
  📄 .gitignore
  📁 .pytest_cache/
    📄 .gitignore
    📄 CACHEDIR.TAG
    📄 README.md
      # pytest cache directory #
      
      This directory contains data from the pytest's cache plugin,
      which provides the `--lf` and `--ff` options, as well as the `cache` fixture.
      
      **Do not** commit this to version control.
      
      See [the docs](https://docs.pytest.org/en/latest/cache.html) for more information.
    📁 v/
      📁 cache/
        📄 lastfailed
        📄 nodeids
        📄 stepwise
  📁 build/
    📁 bdist.linux-x86_64/
    📁 lib/
      📁 dirscribe/
        📄 __init__.py
          """
          DirScribe
          
          A Python package that helps you export a directory structure and optionally
          the contents of files with certain extensions.
          """
          
          __version__ = "0.1.0"
          
          from .core import export_directory_structure, main
        📄 core.py
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          
          import argparse
          import json
          import time
          from pathlib import Path
          from typing import List, Optional, Union, Dict, Any, Tuple
          
          
          #: A default dictionary for mapping file extensions to language names.
          LANGUAGE_MAP = {
              ".py": "Python",
              ".js": "JavaScript",
              ".ts": "TypeScript",
              ".java": "Java",
              ".rb": "Ruby",
              ".php": "PHP",
              ".html": "HTML",
              ".css": "CSS",
              ".cpp": "C++",
              ".c": "C",
              ".go": "Go",
              ".rs": "Rust",
              ".swift": "Swift",
          }
          
          
          def scan_directory(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False
          ) -> Dict[str, Any]:
              """
              Recursively scans the target directory and builds a nested dictionary
              representing directories and files. File contents are included only for
              certain extensions if specified. Additional features include skipping hidden
              files/folders, limiting file read size, adding metadata, and detecting
              programming language based on file extension.
          
              Args:
                  target_dir (Path):
                      The directory path to scan.
                  include_extensions (List[str], optional):
                      List of file extensions (e.g., [".py", ".txt"]) whose contents
                      should be included. If None or empty, contents are not included.
                  skip_hidden (bool):
                      If True, hidden files and directories (name starts with '.') are skipped.
                  max_size (int, optional):
                      Maximum file size (in bytes) to read. Files exceeding this size
                      will not have their contents read.
                  show_metadata (bool):
                      If True, include file metadata (size, modification time).
                  detect_language (bool):
                      If True, attach a "language" field in the result based on file extension.
          
              Returns:
                  Dict[str, Any]:
                      A nested dictionary structure describing the directory tree.
                      Example structure:
                      {
                        "type": "directory",
                        "name": "some_dir",
                        "path": "/absolute/path/to/some_dir",
                        "children": [
                          {
                            "type": "file",
                            "name": "main.py",
                            "path": "...",
                            "language": "Python",
                            "content": "...",
                            "metadata": {...}
                          },
                          ...
                        ]
                      }
              """
              if not target_dir.exists():
                  return {
                      "type": "error",
                      "message": f"Directory does not exist: {target_dir}"
                  }
          
              tree = {
                  "type": "directory",
                  "name": target_dir.name,
                  "path": str(target_dir.resolve()),
                  "children": []
              }
          
              try:
                  entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
              except PermissionError:
                  tree["children"].append({
                      "type": "error",
                      "message": f"Permission denied: {target_dir}"
                  })
                  return tree
          
              for entry in entries:
                  # Skip hidden files/directories if skip_hidden == True
                  if skip_hidden and entry.name.startswith('.'):
                      continue
          
                  if entry.is_dir():
                      subtree = scan_directory(
                          entry,
                          include_extensions=include_extensions,
                          skip_hidden=skip_hidden,
                          max_size=max_size,
                          show_metadata=show_metadata,
                          detect_language=detect_language
                      )
                      tree["children"].append(subtree)
                  else:
                      file_node = {
                          "type": "file",
                          "name": entry.name,
                          "path": str(entry.resolve())
                      }
          
                      # Detect language if requested
                      if detect_language:
                          lang = LANGUAGE_MAP.get(entry.suffix.lower())
                          if lang:
                              file_node["language"] = lang
          
                      # Show metadata if requested
                      if show_metadata:
                          file_node["metadata"] = _get_file_metadata(entry)
          
                      # Include file content if extension is in include_extensions
                      if include_extensions and len(include_extensions) > 0:
                          if entry.suffix.lower() in [ext.lower() for ext in include_extensions]:
                              if max_size is not None and entry.stat().st_size > max_size:
                                  file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                              else:
                                  file_node["content"] = _read_file_content(entry)
                      tree["children"].append(file_node)
          
              return tree
          
          
          def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
              """
              Builds a list of text lines (ASCII tree style) from the nested dictionary.
          
              Args:
                  tree (Dict[str, Any]):
                      A dictionary structure as returned by scan_directory().
                  indent_level (int):
                      Internal parameter for recursion to manage text indentation.
          
              Returns:
                  List[str]:
                      A list of lines representing the directory tree and file contents.
              """
              lines = []
          
              node_type = tree.get("type")
              node_name = tree.get("name", "unknown")
          
              if node_type == "error":
                  msg = tree.get("message", "Unknown error")
                  lines.append("  " * indent_level + f"[Error] {msg}")
                  return lines
          
              if node_type == "directory":
                  lines.append("  " * indent_level + f"📁 {node_name}/")
                  children = tree.get("children", [])
                  for child in children:
                      lines.extend(build_text_output(child, indent_level + 1))
          
              elif node_type == "file":
                  # Show file with language if present
                  language = tree.get("language")
                  if language:
                      lines.append("  " * indent_level + f"📄 {node_name} ({language})")
                  else:
                      lines.append("  " * indent_level + f"📄 {node_name}")
          
                  content = tree.get("content")
                  if content is not None:
                      for c_line in content.splitlines():
                          lines.append("  " * (indent_level + 1) + c_line)
          
                  metadata = tree.get("metadata")
                  if metadata:
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
          
              return lines
          
          
          def export_directory_structure(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False,
              output_format: str = "text",
              output_file: Optional[Path] = None
          ) -> Union[List[str], str]:
              """
              Scans the directory and produces output in either text or JSON format.
              Optionally writes the result to a file if output_file is specified.
          
              Args:
                  target_dir (Path):
                      The directory path to scan.
                  include_extensions (List[str], optional):
                      File extensions to include content for (e.g., [".py", ".txt"]).
                  skip_hidden (bool):
                      Whether to skip hidden files/directories.
                  max_size (int, optional):
                      Maximum file size (in bytes) to read. If None, no limit is enforced.
                  show_metadata (bool):
                      If True, include file metadata.
                  detect_language (bool):
                      If True, attempt to detect code language based on file extension.
                  output_format (str):
                      Output format: "text" or "json". Default is "text".
                  output_file (Path, optional):
                      If provided, the resulting output will be written to this file
                      instead of being returned.
          
              Returns:
                  Union[List[str], str]:
                      - If output_format="text" and output_file is None, returns a list of lines.
                      - If output_format="json" and output_file is None, returns a JSON string.
                      - If output_file is specified, the function writes to that file and
                        returns an empty string or list (depending on the format) for convenience.
              """
              tree = scan_directory(
                  target_dir=target_dir,
                  include_extensions=include_extensions,
                  skip_hidden=skip_hidden,
                  max_size=max_size,
                  show_metadata=show_metadata,
                  detect_language=detect_language
              )
          
              if output_format not in ["text", "json"]:
                  raise ValueError("Invalid output format. Choose 'text' or 'json'.")
          
              # Build output (text or json)
              if output_format == "text":
                  output_data = build_text_output(tree, indent_level=0)  # list of strings
              else:
                  output_data = json.dumps(tree, indent=2)  # JSON string
          
              # If an output_file is specified, write the data and return an empty list/string
              if output_file is not None:
                  if output_format == "text":
                      # Join lines with newline
                      text_content = "\n".join(output_data)
                      output_file.write_text(text_content, encoding="utf-8")
                      return []
                  else:
                      # JSON string
                      output_file.write_text(output_data, encoding="utf-8")
                      return ""
              else:
                  # Return the data directly
                  return output_data
          
          
          def main():
              """
              CLI entry point for DirScribe. Parses command-line arguments
              and prints or writes the directory structure.
              """
              parser = argparse.ArgumentParser(
                  description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
              )
              parser.add_argument("directory", type=str, help="Path to the directory to scan.")
              parser.add_argument(
                  "-e", "--extensions", nargs="*", default=[],
                  help="List of file extensions to include content for (e.g. -e .py .txt)."
              )
              parser.add_argument(
                  "--skip-hidden", action="store_true",
                  help="Skip hidden files and directories."
              )
              parser.add_argument(
                  "--max-size", type=int, default=None,
                  help="Maximum file size (bytes) to read. Larger files will be skipped."
              )
              parser.add_argument(
                  "--show-metadata", action="store_true",
                  help="Include file metadata (size, modified time) in the output."
              )
              parser.add_argument(
                  "--detect-language", action="store_true",
                  help="Attach a 'language' field based on file extension (e.g., '.py' -> 'Python')."
              )
              parser.add_argument(
                  "--output-format", choices=["text", "json"], default="text",
                  help="Choose output format: 'text' or 'json'. Default is 'text'."
              )
              parser.add_argument(
                  "--output-file", type=str, default=None,
                  help="If specified, write the output to this file instead of stdout."
              )
          
              args = parser.parse_args()
          
              directory = Path(args.directory).resolve()
              output_file = Path(args.output_file).resolve() if args.output_file else None
          
              result = export_directory_structure(
                  target_dir=directory,
                  include_extensions=args.extensions,
                  skip_hidden=args.skip_hidden,
                  max_size=args.max_size,
                  show_metadata=args.show_metadata,
                  detect_language=args.detect_language,
                  output_format=args.output_format,
                  output_file=output_file
              )
          
              # If output_file was specified, nothing is printed to stdout (by design).
              # Otherwise, print the result to stdout.
              if not output_file:
                  if args.output_format == "text":
                      # 'result' is a list of lines
                      for line in result:  # type: ignore
                          print(line)
                  else:
                      # 'result' is a JSON string
                      print(result)  # type: ignore
          
          
          def _read_file_content(file_path: Path) -> str:
              """
              Safely reads text content from a file using UTF-8 (replace errors).
          
              Args:
                  file_path (Path):
                      Path object for the file to read.
          
              Returns:
                  str:
                      The file's text content (with unknown chars replaced).
              """
              try:
                  return file_path.read_text(encoding="utf-8", errors="replace")
              except Exception as e:
                  return f"<<Error reading file: {e}>>"
          
          
          def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
              """
              Retrieves basic metadata: file size in bytes, last modified time in ISO format.
          
              Args:
                  file_path (Path):
                      Path object to the file.
          
              Returns:
                  Dict[str, Union[int, str]]:
                      A dictionary containing file size and modified timestamp (ISO).
              """
              size = file_path.stat().st_size
              mtime = file_path.stat().st_mtime
              modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
              return {
                  "size": size,
                  "modified": modified_iso
              }
          
          
          if __name__ == "__main__":
              main()
  📄 CHANGELOG.md
    # Changelog
    
    All notable changes to this project will be documented here.
    
    ## [0.1.0] - 2025-01-19
    ### Added
    - Initial release of DirScribe
    - Recursive directory scanning
    - Optional file-content inclusion via extensions
  📄 CODE_OF_CONDUCT.md
    # Contributor Covenant Code of Conduct
    
    ## Our Pledge
    
    We as members, contributors, and leaders pledge to make participation in our
    community a harassment-free experience for everyone, regardless of age, body size,
    disability, ethnicity, gender identity and expression, level of experience,
    nationality, personal appearance, race, religion, or sexual identity and orientation.
    
    We pledge to act and interact in ways that contribute to an open, welcoming,
    diverse, inclusive, and healthy community.
    
    ## Our Standards
    
    Examples of behavior that contributes to a positive environment:
    - Using welcoming and inclusive language
    - Being respectful of differing viewpoints and experiences
    - Gracefully accepting constructive criticism
    - Focusing on what is best for the community
    
    Examples of unacceptable behavior:
    - The use of sexualized language or imagery, and unwelcome sexual attention
    - Insults or personal attacks
    - Harassment in any form
    - Other conduct which could reasonably be considered inappropriate in a professional setting
    
    ## Enforcement
    
    Instances of abusive, harassing, or otherwise unacceptable behavior may be reported
    by contacting the project team. All complaints will be reviewed and investigated 
    and will result in a response deemed necessary and appropriate to the circumstances.
  📄 CONTRIBUTING.md
    # Contributing to DirScribe
    
    Thank you for your interest in contributing to DirScribe! This document explains how to submit pull requests (PRs), report issues, and follow best practices for a smooth contribution process.
    
    ## Development Setup
    
    1. **Fork** the repository on GitHub, then clone it locally.
    2. Create a feature branch:
       ```bash
       git checkout -b feature/my-awesome-feature
       ```
    3. Install and test the package:
       ```bash
       pip install -e .[dev]
       pytest
       ```
    
    ## Coding Style
    
    * Adhere to PEP 8 for Python code style whenever possible.
    * Write clear docstrings or comments to help others understand your code.
    
    ## Commit Messages
    
    * Keep commit messages concise but descriptive.
    * Make incremental commits that each address a single topic or issue if possible.
    
    ## Pull Requests
    
    1. Verify that all tests pass and your changes are documented.
    2. Open a PR against the `main` branch with a clear title and description.
    3. In the PR body, describe what changes you made and why. Include any relevant issue numbers.
    4. Be prepared to address review feedback; update your branch with additional commits as needed.
    
    ## Issue Reporting
    
    * Use GitHub Issues for bug reports, feature requests, or questions.
    * Provide as much detail as possible, including steps to reproduce bugs if applicable.
    
    ## License
    
    * DirScribe is distributed under the MIT License.
    * Any contributions you make will also fall under that same license.
    
    Thank you for your contributions and support!
  📁 dirscribe/
    📄 __init__.py
      """
      DirScribe
      
      A Python package that helps you export a directory structure and optionally
      the contents of files with certain extensions.
      """
      
      __version__ = "0.1.0"
      
      from .core import export_directory_structure, main
    📁 __pycache__/
      📄 __init__.cpython-310.pyc
      📄 core.cpython-310.pyc
    📄 core.py
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      
      import argparse
      import json
      import time
      from pathlib import Path
      from typing import List, Optional, Union, Dict, Any, Tuple
      
      
      #: A default dictionary for mapping file extensions to language names.
      LANGUAGE_MAP = {
          ".py": "Python",
          ".js": "JavaScript",
          ".ts": "TypeScript",
          ".java": "Java",
          ".rb": "Ruby",
          ".php": "PHP",
          ".html": "HTML",
          ".css": "CSS",
          ".cpp": "C++",
          ".c": "C",
          ".go": "Go",
          ".rs": "Rust",
          ".swift": "Swift",
      }
      
      
      def scan_directory(
          target_dir: Path,
          include_extensions: Optional[List[str]] = None,
          skip_hidden: bool = False,
          max_size: Optional[int] = None,
          show_metadata: bool = False,
          detect_language: bool = False
      ) -> Dict[str, Any]:
          """
          Recursively scans the target directory and builds a nested dictionary
          representing directories and files. File contents are included only for
          certain extensions if specified. Additional features include skipping hidden
          files/folders, limiting file read size, adding metadata, and detecting
          programming language based on file extension.
      
          Args:
              target_dir (Path):
                  The directory path to scan.
              include_extensions (List[str], optional):
                  List of file extensions (e.g., [".py", ".txt"]) whose contents
                  should be included. If None or empty, contents are not included.
              skip_hidden (bool):
                  If True, hidden files and directories (name starts with '.') are skipped.
              max_size (int, optional):
                  Maximum file size (in bytes) to read. Files exceeding this size
                  will not have their contents read.
              show_metadata (bool):
                  If True, include file metadata (size, modification time).
              detect_language (bool):
                  If True, attach a "language" field in the result based on file extension.
      
          Returns:
              Dict[str, Any]:
                  A nested dictionary structure describing the directory tree.
                  Example structure:
                  {
                    "type": "directory",
                    "name": "some_dir",
                    "path": "/absolute/path/to/some_dir",
                    "children": [
                      {
                        "type": "file",
                        "name": "main.py",
                        "path": "...",
                        "language": "Python",
                        "content": "...",
                        "metadata": {...}
                      },
                      ...
                    ]
                  }
          """
          if not target_dir.exists():
              return {
                  "type": "error",
                  "message": f"Directory does not exist: {target_dir}"
              }
      
          tree = {
              "type": "directory",
              "name": target_dir.name,
              "path": str(target_dir.resolve()),
              "children": []
          }
      
          try:
              entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
          except PermissionError:
              tree["children"].append({
                  "type": "error",
                  "message": f"Permission denied: {target_dir}"
              })
              return tree
      
          for entry in entries:
              # Skip hidden files/directories if skip_hidden == True
              if skip_hidden and entry.name.startswith('.'):
                  continue
      
              if entry.is_dir():
                  subtree = scan_directory(
                      entry,
                      include_extensions=include_extensions,
                      skip_hidden=skip_hidden,
                      max_size=max_size,
                      show_metadata=show_metadata,
                      detect_language=detect_language
                  )
                  tree["children"].append(subtree)
              else:
                  file_node = {
                      "type": "file",
                      "name": entry.name,
                      "path": str(entry.resolve())
                  }
      
                  # Detect language if requested
                  if detect_language:
                      lang = LANGUAGE_MAP.get(entry.suffix.lower())
                      if lang:
                          file_node["language"] = lang
      
                  # Show metadata if requested
                  if show_metadata:
                      file_node["metadata"] = _get_file_metadata(entry)
      
                  # Include file content if extension is in include_extensions
                  if include_extensions and len(include_extensions) > 0:
                      if entry.suffix.lower() in [ext.lower() for ext in include_extensions]:
                          if max_size is not None and entry.stat().st_size > max_size:
                              file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                          else:
                              file_node["content"] = _read_file_content(entry)
                  tree["children"].append(file_node)
      
          return tree
      
      
      def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
          """
          Builds a list of text lines (ASCII tree style) from the nested dictionary.
      
          Args:
              tree (Dict[str, Any]):
                  A dictionary structure as returned by scan_directory().
              indent_level (int):
                  Internal parameter for recursion to manage text indentation.
      
          Returns:
              List[str]:
                  A list of lines representing the directory tree and file contents.
          """
          lines = []
      
          node_type = tree.get("type")
          node_name = tree.get("name", "unknown")
      
          if node_type == "error":
              msg = tree.get("message", "Unknown error")
              lines.append("  " * indent_level + f"[Error] {msg}")
              return lines
      
          if node_type == "directory":
              lines.append("  " * indent_level + f"📁 {node_name}/")
              children = tree.get("children", [])
              for child in children:
                  lines.extend(build_text_output(child, indent_level + 1))
      
          elif node_type == "file":
              # Show file with language if present
              language = tree.get("language")
              if language:
                  lines.append("  " * indent_level + f"📄 {node_name} ({language})")
              else:
                  lines.append("  " * indent_level + f"📄 {node_name}")
      
              content = tree.get("content")
              if content is not None:
                  for c_line in content.splitlines():
                      lines.append("  " * (indent_level + 1) + c_line)
      
              metadata = tree.get("metadata")
              if metadata:
                  lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                  lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
      
          return lines
      
      
      def export_directory_structure(
          target_dir: Path,
          include_extensions: Optional[List[str]] = None,
          skip_hidden: bool = False,
          max_size: Optional[int] = None,
          show_metadata: bool = False,
          detect_language: bool = False,
          output_format: str = "text",
          output_file: Optional[Path] = None
      ) -> Union[List[str], str]:
          """
          Scans the directory and produces output in either text or JSON format.
          Optionally writes the result to a file if output_file is specified.
      
          Args:
              target_dir (Path):
                  The directory path to scan.
              include_extensions (List[str], optional):
                  File extensions to include content for (e.g., [".py", ".txt"]).
              skip_hidden (bool):
                  Whether to skip hidden files/directories.
              max_size (int, optional):
                  Maximum file size (in bytes) to read. If None, no limit is enforced.
              show_metadata (bool):
                  If True, include file metadata.
              detect_language (bool):
                  If True, attempt to detect code language based on file extension.
              output_format (str):
                  Output format: "text" or "json". Default is "text".
              output_file (Path, optional):
                  If provided, the resulting output will be written to this file
                  instead of being returned.
      
          Returns:
              Union[List[str], str]:
                  - If output_format="text" and output_file is None, returns a list of lines.
                  - If output_format="json" and output_file is None, returns a JSON string.
                  - If output_file is specified, the function writes to that file and
                    returns an empty string or list (depending on the format) for convenience.
          """
          tree = scan_directory(
              target_dir=target_dir,
              include_extensions=include_extensions,
              skip_hidden=skip_hidden,
              max_size=max_size,
              show_metadata=show_metadata,
              detect_language=detect_language
          )
      
          if output_format not in ["text", "json"]:
              raise ValueError("Invalid output format. Choose 'text' or 'json'.")
      
          # Build output (text or json)
          if output_format == "text":
              output_data = build_text_output(tree, indent_level=0)  # list of strings
          else:
              output_data = json.dumps(tree, indent=2)  # JSON string
      
          # If an output_file is specified, write the data and return an empty list/string
          if output_file is not None:
              if output_format == "text":
                  # Join lines with newline
                  text_content = "\n".join(output_data)
                  output_file.write_text(text_content, encoding="utf-8")
                  return []
              else:
                  # JSON string
                  output_file.write_text(output_data, encoding="utf-8")
                  return ""
          else:
              # Return the data directly
              return output_data
      
      
      def main():
          """
          CLI entry point for DirScribe. Parses command-line arguments
          and prints or writes the directory structure.
          """
          parser = argparse.ArgumentParser(
              description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
          )
          parser.add_argument("directory", type=str, help="Path to the directory to scan.")
          parser.add_argument(
              "-e", "--extensions", nargs="*", default=[],
              help="List of file extensions to include content for (e.g. -e .py .txt)."
          )
          parser.add_argument(
              "--skip-hidden", action="store_true",
              help="Skip hidden files and directories."
          )
          parser.add_argument(
              "--max-size", type=int, default=None,
              help="Maximum file size (bytes) to read. Larger files will be skipped."
          )
          parser.add_argument(
              "--show-metadata", action="store_true",
              help="Include file metadata (size, modified time) in the output."
          )
          parser.add_argument(
              "--detect-language", action="store_true",
              help="Attach a 'language' field based on file extension (e.g., '.py' -> 'Python')."
          )
          parser.add_argument(
              "--output-format", choices=["text", "json"], default="text",
              help="Choose output format: 'text' or 'json'. Default is 'text'."
          )
          parser.add_argument(
              "--output-file", type=str, default=None,
              help="If specified, write the output to this file instead of stdout."
          )
      
          args = parser.parse_args()
      
          directory = Path(args.directory).resolve()
          output_file = Path(args.output_file).resolve() if args.output_file else None
      
          result = export_directory_structure(
              target_dir=directory,
              include_extensions=args.extensions,
              skip_hidden=args.skip_hidden,
              max_size=args.max_size,
              show_metadata=args.show_metadata,
              detect_language=args.detect_language,
              output_format=args.output_format,
              output_file=output_file
          )
      
          # If output_file was specified, nothing is printed to stdout (by design).
          # Otherwise, print the result to stdout.
          if not output_file:
              if args.output_format == "text":
                  # 'result' is a list of lines
                  for line in result:  # type: ignore
                      print(line)
              else:
                  # 'result' is a JSON string
                  print(result)  # type: ignore
      
      
      def _read_file_content(file_path: Path) -> str:
          """
          Safely reads text content from a file using UTF-8 (replace errors).
      
          Args:
              file_path (Path):
                  Path object for the file to read.
      
          Returns:
              str:
                  The file's text content (with unknown chars replaced).
          """
          try:
              return file_path.read_text(encoding="utf-8", errors="replace")
          except Exception as e:
              return f"<<Error reading file: {e}>>"
      
      
      def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
          """
          Retrieves basic metadata: file size in bytes, last modified time in ISO format.
      
          Args:
              file_path (Path):
                  Path object to the file.
      
          Returns:
              Dict[str, Union[int, str]]:
                  A dictionary containing file size and modified timestamp (ISO).
          """
          size = file_path.stat().st_size
          mtime = file_path.stat().st_mtime
          modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
          return {
              "size": size,
              "modified": modified_iso
          }
      
      
      if __name__ == "__main__":
          main()
  📁 dirscribe.egg-info/
    📄 dependency_links.txt
    📄 entry_points.txt
    📄 PKG-INFO
    📄 SOURCES.txt
    📄 top_level.txt
  📄 LICENSE
  📄 MANIFEST.in
  📄 pyproject.toml
  📄 README.md
    # DirScribe — Explore, Document, and Share Your Directory Structures
    
    <p align="center">
      <img src="https://img.shields.io/badge/version-0.1.0-blue.svg" alt="Version">
      <img src="https://img.shields.io/badge/license-MIT-green.svg" alt="License">
      <img src="https://img.shields.io/badge/Python-3.7+-brightgreen.svg" alt="Python 3.7+">
      <img src="https://img.shields.io/github/stars/kkwmr/dirscribe?style=social" alt="Stars">
    </p>
    
    DirScribe is a **lightweight yet powerful** CLI tool and Python library for **exporting directory structures** in either **text** or **JSON** format. It helps you **optionally** include file contents, **detect programming languages**, skip hidden items, limit file reading by size, show metadata (size and modification time), and output results directly to your terminal or a file.
    
    Created by: Kazuki Kawamura (Caspy /ˈkæspi/, かすぴー)
    > **License:** [MIT License](./LICENSE)
    
    ## Table of Contents
    1. [Key Features](#key-features)  
    2. [Why DirScribe?](#why-dirscribe)  
    3. [Installation](#installation)  
    4. [Quick Start](#quick-start)  
    5. [Command-Line Usage](#command-line-usage)  
    6. [Python Library Usage](#python-library-usage)  
    7. [Use Cases](#use-cases)  
    8. [Contributing](#contributing)  
    9. [License](#license)  
    
    ## Key Features
    
    - **Text or JSON Output**: Choose between a human-readable tree format or a structured JSON representation for advanced integrations.
    - **File Content Inclusion**: Display the contents of files for specific extensions (e.g., `.py`, `.js`, `.txt`, etc.).
    - **Language Detection**: Show the programming language name (e.g., `.py` -> *Python*) alongside file names.
    - **Skip Hidden**: Omit hidden files and directories (those starting with a dot).
    - **Maximum Size Limit**: Automatically skip file content if a file exceeds a specified byte-size.
    - **Metadata Display**: Show file size and last modification timestamp in the output.
    - **Save to File**: Output can be redirected to a file rather than just printing to the console.
    - **Highly Configurable**: Combine various options to fit your exact needs.
    
    ## Why DirScribe?
    
    - **Instant Documentation**: Quickly generate a snapshot of your codebase – perfect for onboarding new team members or archiving project structures.
    - **Efficient Code Reviews**: Include file contents up to a specified size, letting you skim important files without digging into each folder manually.
    - **Language Insights**: Recognize the languages used in your project at a glance.
    - **Scriptable**: Integrate DirScribe into CI/CD pipelines or other automated workflows to maintain updated structure maps.
    - **Open Source & Community-Driven**: MIT-licensed and easy to extend.
    
    ## Installation
    
    You can install DirScribe either by cloning this repository or from your own distribution setup:
    
    ```bash
    # From source (assuming you're in the DirScribe project directory):
    pip install .
    ```
    
    If you're editing the source, you might prefer:
    
    ```bash
    pip install -e .
    ```
    
    (This sets up DirScribe in "editable" mode so changes in the code take immediate effect.)
    
    If DirScribe is published on PyPI in the future, you'll be able to run `pip install dirscribe` directly.
    
    ## Quick Start
    
    Generate a text listing of a directory:
    
    ```bash
    dirscribe /path/to/project
    ```
    
    Generate a JSON output and save it to a file:
    
    ```bash
    dirscribe /path/to/project --output-format json --output-file project_structure.json
    ```
    
    That's it! Customize the output further using the rich set of options explained below.
    
    ## Command-Line Usage
    
    Once installed, you can run dirscribe in your terminal:
    
    ```bash
    dirscribe [DIRECTORY] [OPTIONS]
    ```
    
    ### Common Options
    
    - `-e, --extensions <EXT ...>`  
      Specify which file extensions to include content for (e.g. -e .py .js).
    
    - `--detect-language`  
      Enables language detection based on file extensions.  
      Example: .py -> Python, .js -> JavaScript, etc.
    
    - `--skip-hidden`  
      Skips files and directories whose names begin with `.`
    
    - `--max-size <BYTES>`  
      Maximum file size (in bytes) to read. Files larger than this are ignored (content not shown).
    
    - `--show-metadata`  
      Displays file metadata (size in bytes, last modification time) next to file content.
    
    - `--output-format <text|json>`  
      Output either a text-based tree or JSON structure. Defaults to text.
    
    - `--output-file <FILE>`  
      Write the output to the specified file instead of printing to stdout.
    
    ### Example: Combine Multiple Options
    
    ```bash
    dirscribe /path/to/src \
      -e .py .html \
      --detect-language \
      --skip-hidden \
      --max-size 2000 \
      --show-metadata \
      --output-format text \
      --output-file output.txt
    ```
    
    What it does:
    - Recursively scans `/path/to/src`
    - Shows contents of files with `.py` or `.html` extension (up to 2000 bytes)
    - Skips hidden items (names starting with .)
    - Displays file size & last modified time
    - Identifies language names where possible
    - Renders as a textual tree
    - Saves it to output.txt (instead of printing to the terminal)
    
    ## Python Library Usage
    
    DirScribe can also be used as a library in your Python scripts or applications:
    
    ```python
    from pathlib import Path
    from dirscribe.core import export_directory_structure
    
    def main():
        directory = Path("/path/to/src")
        
        # Export directory structure as text (list of lines)
        lines = export_directory_structure(
            target_dir=directory,
            include_extensions=[".py", ".html"],
            skip_hidden=True,
            max_size=2000,
            show_metadata=True,
            detect_language=True,
            output_format="text",
            output_file=None  # If you'd like to write to a file, pass Path("output.txt")
        )
        
        # If output_format="text" and output_file=None, you get a list of lines
        for line in lines:
            print(line)
    
    if __name__ == "__main__":
        main()
    ```
    
    ### Parameters
    
    - `target_dir (Path)`: The folder you want to scan.
    - `include_extensions (List[str], optional)`: List of extensions for which file contents should be shown.
    - `skip_hidden (bool, default=False)`: Skip hidden files/directories.
    - `max_size (int, optional)`: Skip content for files larger than this size.
    - `show_metadata (bool, default=False)`: Show size and last modification time.
    - `detect_language (bool, default=False)`: Attach a language field based on file extension.
    - `output_format (str, default="text")`: Either "text" or "json".
    - `output_file (Path, optional)`: If provided, write output to that file.
    
    The function returns:
    - A list of strings (text lines) if `output_format="text"` and `output_file=None`, or
    - A JSON string if `output_format="json"` and `output_file=None`.
    - If `output_file` is set, the data is written to the file, and the function returns an empty list or empty string.
    
    ## Use Cases
    
    ### Instant Project Documentation
    Generate a tree-like structure of your source code, complete with file contents (for specific extensions) and metadata.
    Ideal for:
    - Sharing with collaborators
    - Creating "at-a-glance" docs
    
    ### Code Review & Auditing
    Quickly see which files exist, their languages, and read short/medium files directly without jumping between directories.
    
    ### Security / Compliance Checks
    Skip hidden or large files, or selectively scan certain file types to ensure they meet certain criteria.
    
    ### CI/CD Integration
    Save a JSON manifest of your repository structure as part of your build artifacts. Compare structure between builds or track changes over time.
    
    ### Scripting / Automation
    If you need to parse directory contents in a custom pipeline, DirScribe's Python API and JSON output can be easily integrated.
    
    ## Contributing
    
    Contributions, suggestions, and bug reports are warmly welcomed! Check out our [CONTRIBUTING.md](./CONTRIBUTING.md) to learn how to propose changes or open pull requests.
    We also encourage you to open an issue if you encounter problems or have feature requests.
    
    Ways to help:
    - Code contributions (new features, bug fixes, refactoring)
    - Documentation improvements (clarify instructions, add examples)
    - Language mapping expansions (add more file extensions to LANGUAGE_MAP)
    - Feedback and testing on different OS environments or large-scale projects
    
    If you find DirScribe valuable, please consider starring the repository and sharing it with your fellow developers!
    
    ## License
    
    This project is distributed under the MIT License.
    © 2025 Kazuki Kawamura
  📄 requirements-dev.txt
  📄 setup.py
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    from setuptools import setup, find_packages
    
    setup(
        name="dirscribe",
        version="0.1.0",
        description="A tool to export directory structure and optionally include file contents for selected extensions.",
        long_description="DirScribe is a Python package and CLI that helps you turn a directory's structure into text, with optional file content inclusion.",
        long_description_content_type="text/markdown",
        author="Kazuki Kawamura",
        url="https://github.com/kkwmr/dirscribe",
        packages=find_packages(),
        python_requires=">=3.7",
        entry_points={
            "console_scripts": [
                "dirscribe=dirscribe.core:main"
            ]
        },
        classifiers=[
            "Programming Language :: Python :: 3",
            "License :: OSI Approved :: MIT License",
            "Operating System :: OS Independent"
        ],
        license="MIT"
    )
  📁 tests/
    📁 __pycache__/
      📄 test_basic.cpython-27-PYTEST.pyc
      📄 test_basic.cpython-310-pytest-8.3.4.pyc
    📄 test_basic.py
      import tempfile
      from pathlib import Path
      import pytest
      
      from dirscribe.core import (
          export_directory_structure,
          scan_directory
      )
      
      
      def test_scan_empty_directory():
          """
          Tests scanning an empty directory. The result should have no children.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              tree = scan_directory(tmp_path)
              assert tree["type"] == "directory"
              assert len(tree["children"]) == 0
      
      
      def test_skip_hidden():
          """
          Tests that hidden files and directories are skipped when skip_hidden=True.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              # Create a hidden file
              hidden_file = tmp_path / ".hidden.txt"
              hidden_file.write_text("This is hidden", encoding="utf-8")
      
              # Create a normal file
              visible_file = tmp_path / "visible.txt"
              visible_file.write_text("This is visible", encoding="utf-8")
      
              tree = scan_directory(tmp_path, skip_hidden=True)
              # Should see only the visible file
              children_names = [child["name"] for child in tree["children"]]
              assert "visible.txt" in children_names
              assert ".hidden.txt" not in children_names
      
      
      def test_max_size():
          """
          Tests that files exceeding max_size do not have their content read.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              big_file = tmp_path / "bigfile.txt"
              # Write a large content
              big_file.write_text("A" * 5000, encoding="utf-8")
      
              small_file = tmp_path / "smallfile.txt"
              small_file.write_text("Short content", encoding="utf-8")
      
              tree = scan_directory(tmp_path, include_extensions=[".txt"], max_size=1000)
              big_entry = next(child for child in tree["children"] if child["name"] == "bigfile.txt")
              small_entry = next(child for child in tree["children"] if child["name"] == "smallfile.txt")
      
              # big file content should be replaced by a skip message
              assert "content" in big_entry
              assert "exceeds 1000 bytes" in big_entry["content"]
              # small file should contain actual content
              assert small_entry["content"] == "Short content"
      
      
      def test_show_metadata():
          """
          Tests that file metadata is included when show_metadata=True.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              f = tmp_path / "example.txt"
              f.write_text("Hello World", encoding="utf-8")
      
              tree = scan_directory(tmp_path, include_extensions=[".txt"], show_metadata=True)
              file_node = tree["children"][0]
              assert "metadata" in file_node
              assert "size" in file_node["metadata"]
              assert file_node["metadata"]["size"] == len("Hello World")
      
      
      def test_json_output():
          """
          Tests the export_directory_structure output in JSON format.
          Ensures the returned string can be parsed as JSON.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              (tmp_path / "test.py").write_text("print('test')", encoding="utf-8")
      
              output = export_directory_structure(
                  target_dir=tmp_path,
                  include_extensions=[".py"],
                  output_format="json"
              )
              import json
              parsed = json.loads(output)
              assert parsed["type"] == "directory"
              assert parsed["children"][0]["name"] == "test.py"
              assert "print('test')" in parsed["children"][0].get("content", "")
      
      
      if __name__ == "__main__":
          pytest.main([__file__])