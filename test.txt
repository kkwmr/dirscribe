📁 dirscribe/
  📁 .git/
    📁 branches/
    📄 COMMIT_EDITMSG
    📄 config
    📄 description
    📄 HEAD
    📁 hooks/
      📄 applypatch-msg.sample
      📄 commit-msg.sample
      📄 fsmonitor-watchman.sample
      📄 post-update.sample
      📄 pre-applypatch.sample
      📄 pre-commit.sample
      📄 pre-merge-commit.sample
      📄 pre-push.sample
      📄 pre-rebase.sample
      📄 pre-receive.sample
      📄 prepare-commit-msg.sample
      📄 update.sample
    📄 index
    📁 info/
      📄 exclude
    📁 logs/
      📄 HEAD
      📁 refs/
        📁 heads/
          📄 main
        📁 remotes/
          📁 origin/
            📄 main
    📁 objects/
      📁 0e/
        📄 7b24d3c34ff1d4f57029e12a0ed9a447afc2e1
      📁 18/
        📄 0791f3b9750e562dd96939752106089b678e2b
      📁 19/
        📄 1099e8aa4bc3b49c9f10485f3c83a258acb36b
      📁 1b/
        📄 ae5d2e49942d13594c6f3aa2ea29915adf7b37
      📁 36/
        📄 a73a7afd60aa9f24af32c3fccc8ec2f7f39fed
      📁 3b/
        📄 94d9b6343d903a398527621d433e935b852607
      📁 44/
        📄 54c8b82a45039e7129ba452368536bf60268ae
      📁 4d/
        📄 173a646bbdf257211ae246a798dff4724e7f51
      📁 54/
        📄 02ad3b254c098c7fe5074501f5fbddfe1bc25c
      📁 55/
        📄 abe6269ff8a230d10ae9d88f3a45f73998026c
      📁 5f/
        📄 73c6ac039b84b5835e2ad4323a6cf9087ca84c
      📁 60/
        📄 3d4f67046cbfb5452df33959b64995d8f848a4
      📁 61/
        📄 9c23f76d0be9c213f69f54b83d925f53d85792
      📁 71/
        📄 77ec5c59c262e95e9d3e29f9900d640eb1209b
      📁 72/
        📄 a99349f92ad6cdf65b86bcbc17e0115b0052c1
      📁 7e/
        📄 b8a4a6807e48be35fdf1f129907e75229bf495
      📁 8a/
        📄 224a9eb9417670b1ca1a82b17f81b80651eb5b
      📁 97/
        📄 87c3bdf008a57ae3cb2e27a8261eb3f134ff73
      📁 a5/
        📄 b8b5610c39736debb58063a66d941589b31c01
      📁 a9/
        📄 4546d944b15cdcb850afefd6575a1def7d9462
      📁 b8/
        📄 0111c16d345d531c50507f3301a30437eff486
      📁 bf/
        📄 c68f8759cfb2bc629a1dab54353f0c61a41334
      📁 c4/
        📄 d04a08d024e901bb246cc8da9ccf6b49b31909
      📁 ca/
        📄 1a7e5856f6d86106b40128981418e08b71627b
      📁 d5/
        📄 3f8116ec79e4e38df364ca416ec71fc908ba19
      📁 d9/
        📄 8dc5e36cf0c651f2b0bc0702d6fa5f339eba09
      📁 e0/
        📄 35be5e92bb7fb071ed5bf616b35c8d449b61f3
      📁 f6/
        📄 c100e6d7b8539053c2afec43081ab07715f2ea
      📁 fb/
        📄 96d0eb93178eaabf8967073e8a2a6d0b8b03a6
        📄 fd31beab538a41c3d047db65f569f8dac09885
      📁 info/
      📁 pack/
    📁 refs/
      📁 heads/
        📄 main
      📁 remotes/
        📁 origin/
          📄 main
      📁 tags/
        📄 v0.1.0
        📄 v0.1.1
  📄 .gitignore
  📁 .pytest_cache/
    📄 .gitignore
    📄 CACHEDIR.TAG
    📄 README.md
      # pytest cache directory #
      
      This directory contains data from the pytest's cache plugin,
      which provides the `--lf` and `--ff` options, as well as the `cache` fixture.
      
      **Do not** commit this to version control.
      
      See [the docs](https://docs.pytest.org/en/latest/cache.html) for more information.
    📁 v/
      📁 cache/
        📄 lastfailed
        📄 nodeids
        📄 stepwise
  📁 build/
    📁 bdist.linux-x86_64/
    📁 lib/
      📁 dirscribe/
        📄 __init__.py
          """
          DirScribe
          
          A Python package that helps you export a directory structure and optionally
          the contents of files with certain extensions.
          """
          
          __version__ = "0.1.1"
          
          from .core import export_directory_structure, main
        📄 core.py
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          
          import argparse
          import json
          import time
          import sys
          from pathlib import Path
          from typing import List, Optional, Union, Dict, Any
          
          try:
              import pyperclip
          except ImportError:
              pyperclip = None
          
          #: A default dictionary for mapping file extensions to language names.
          LANGUAGE_MAP = {
              ".py": "Python",
              ".js": "JavaScript",
              ".ts": "TypeScript",
              ".java": "Java",
              ".rb": "Ruby",
              ".php": "PHP",
              ".html": "HTML",
              ".css": "CSS",
              ".cpp": "C++",
              ".c": "C",
              ".go": "Go",
              ".rs": "Rust",
              ".swift": "Swift",
          }
          
          
          def scan_directory(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False
          ) -> Dict[str, Any]:
              """
              Recursively scans the target directory and builds a nested dictionary
              representing directories and files. File contents are included only for
              certain extensions if specified.
          
              Args:
                  target_dir (Path):
                      The directory path to scan.
                  include_extensions (List[str], optional):
                      A list of file extensions to include content for. If None, all files are included.
                      If an empty list, no file content is included.
                  skip_hidden (bool):
                      If True, hidden files and directories (names starting with '.') are skipped.
                  max_size (int, optional):
                      Maximum file size in bytes to read. Files larger than this are skipped.
                  show_metadata (bool):
                      If True, file metadata (size, modified time) is included in the output.
                  detect_language (bool):
                      If True, a "language" field is added to each file based on extension.
          
              Returns:
                  Dict[str, Any]: A nested dictionary describing the directory structure.
              """
              if not target_dir.exists():
                  return {
                      "type": "error",
                      "message": f"Directory does not exist: {target_dir}"
                  }
          
              tree = {
                  "type": "directory",
                  "name": target_dir.name,
                  "path": str(target_dir.resolve()),
                  "children": []
              }
          
              try:
                  entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
              except PermissionError:
                  tree["children"].append({
                      "type": "error",
                      "message": f"Permission denied: {target_dir}"
                  })
                  return tree
          
              for entry in entries:
                  # Skip hidden files/directories if skip_hidden == True
                  if skip_hidden and entry.name.startswith('.'):
                      continue
          
                  if entry.is_dir():
                      subtree = scan_directory(
                          entry,
                          include_extensions=include_extensions,
                          skip_hidden=skip_hidden,
                          max_size=max_size,
                          show_metadata=show_metadata,
                          detect_language=detect_language
                      )
                      tree["children"].append(subtree)
                  else:
                      file_node = {
                          "type": "file",
                          "name": entry.name,
                          "path": str(entry.resolve())
                      }
          
                      # Detect language if requested
                      if detect_language:
                          lang = LANGUAGE_MAP.get(entry.suffix.lower())
                          if lang:
                              file_node["language"] = lang
          
                      # Show metadata if requested
                      if show_metadata:
                          file_node["metadata"] = _get_file_metadata(entry)
          
                      # Decide if we include the file content
                      if include_extensions and len(include_extensions) > 0:
                          # If we put "ALL_MODE" into include_extensions, treat as "include all"
                          if "ALL_MODE" in include_extensions:
                              should_include = True
                          else:
                              should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                      elif include_extensions is None:
                          # If include_extensions is None, treat as "include all"
                          should_include = True
                      else:
                          # If it's an empty list, do not include file content
                          should_include = False
          
                      if should_include:
                          size = entry.stat().st_size
                          if max_size is not None and size > max_size:
                              file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                          else:
                              file_node["content"] = _read_file_content(entry)
          
                      tree["children"].append(file_node)
          
              return tree
          
          
          def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
              """
              Builds a list of text lines (ASCII tree style) from the nested dictionary.
          
              Args:
                  tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
                  indent_level (int): Internal parameter for managing indentation in recursion.
          
              Returns:
                  List[str]: A list of text lines representing the directory tree and optional contents.
              """
              lines = []
          
              node_type = tree.get("type")
              node_name = tree.get("name", "unknown")
          
              if node_type == "error":
                  msg = tree.get("message", "Unknown error")
                  lines.append("  " * indent_level + f"[Error] {msg}")
                  return lines
          
              if node_type == "directory":
                  lines.append("  " * indent_level + f"📁 {node_name}/")
                  children = tree.get("children", [])
                  for child in children:
                      lines.extend(build_text_output(child, indent_level + 1))
          
              elif node_type == "file":
                  language = tree.get("language")
                  if language:
                      lines.append("  " * indent_level + f"📄 {node_name} ({language})")
                  else:
                      lines.append("  " * indent_level + f"📄 {node_name}")
          
                  content = tree.get("content")
                  if content is not None:
                      for c_line in content.splitlines():
                          lines.append("  " * (indent_level + 1) + c_line)
          
                  metadata = tree.get("metadata")
                  if metadata:
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
          
              return lines
          
          
          def export_directory_structure(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False,
              output_format: str = "text",
              output_file: Optional[Path] = None
          ) -> Union[List[str], str]:
              """
              Scans the directory and produces output in either text or JSON format.
              Optionally writes the result to a file if output_file is specified.
          
              Args:
                  target_dir (Path): The directory to scan.
                  include_extensions (List[str], optional): File extensions to include contents for.
                      If None, includes all. If empty, includes none.
                  skip_hidden (bool): Whether to skip hidden files/directories.
                  max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
                  show_metadata (bool): Whether to include file metadata in the output.
                  detect_language (bool): Whether to add a 'language' field based on file extension.
                  output_format (str): 'text' or 'json'. Default is 'text'.
                  output_file (Path, optional): If specified, the output is written to this file.
          
              Returns:
                  Union[List[str], str]:
                      - If output_format='text' and output_file is None, returns a list of lines.
                      - If output_format='json' and output_file is None, returns a JSON string.
                      - If output_file is specified, writes to file and returns an empty list or string.
              """
              tree = scan_directory(
                  target_dir=target_dir,
                  include_extensions=include_extensions,
                  skip_hidden=skip_hidden,
                  max_size=max_size,
                  show_metadata=show_metadata,
                  detect_language=detect_language
              )
          
              if output_format not in ["text", "json"]:
                  raise ValueError("Invalid output format. Choose 'text' or 'json'.")
          
              if output_format == "text":
                  output_data = build_text_output(tree)
              else:
                  output_data = json.dumps(tree, indent=2)
          
              if output_file is not None:
                  if output_format == "text":
                      # output_data is a list of strings
                      text_content = "\n".join(output_data)
                      output_file.write_text(text_content, encoding="utf-8")
                      return []
                  else:
                      # output_data is a JSON string
                      output_file.write_text(output_data, encoding="utf-8")
                      return ""
              else:
                  return output_data
          
          
          def main():
              """
              CLI entry point for DirScribe. Parses command-line arguments
              and prints or writes the directory structure.
              """
              parser = argparse.ArgumentParser(
                  description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
              )
              parser.add_argument("directory", type=str, help="Path to the directory to scan.")
              parser.add_argument(
                  "-e", "--extensions", nargs="*", default=[],
                  help=(
                      "List of file extensions to include content for (e.g. -e .py .txt). "
                      "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
                  )
              )
              parser.add_argument(
                  "--skip-hidden", action="store_true",
                  help="Skip hidden files and directories."
              )
              parser.add_argument(
                  "--max-size", type=int, default=None,
                  help="Maximum file size (in bytes) to read. Larger files will be skipped."
              )
              parser.add_argument(
                  "--show-metadata", action="store_true",
                  help="Include file metadata (size, modified time) in the output."
              )
              parser.add_argument(
                  "--detect-language", action="store_true",
                  help="Attach a 'language' field based on file extension."
              )
              parser.add_argument(
                  "--output-format", choices=["text", "json"], default="text",
                  help="Choose output format: 'text' or 'json'. Default is 'text'."
              )
              parser.add_argument(
                  "--output-file", type=str, default=None,
                  help="If specified, write the output to this file instead of stdout."
              )
              parser.add_argument(
                  "--clip", action="store_true",
                  help="Copy the output to the clipboard (requires pyperclip)."
              )
          
              args = parser.parse_args()
              directory = Path(args.directory).resolve()
          
              # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
              use_all_extensions = False
              if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
                  use_all_extensions = True
          
              if use_all_extensions:
                  include_exts = None  # None means "include all file contents"
              else:
                  include_exts = args.extensions
          
              output_file = Path(args.output_file).resolve() if args.output_file else None
          
              result = export_directory_structure(
                  target_dir=directory,
                  include_extensions=include_exts,
                  skip_hidden=args.skip_hidden,
                  max_size=args.max_size,
                  show_metadata=args.show_metadata,
                  detect_language=args.detect_language,
                  output_format=args.output_format,
                  output_file=output_file
              )
          
              # If clipboard copy is requested
              if args.clip:
                  if pyperclip is None:
                      print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
                  else:
                      if args.output_format == "text":
                          if isinstance(result, list):
                              text_output = "\n".join(result)
                          else:
                              # If an output file was specified, result might be []
                              text_output = "\n".join(result) if result else ""
                          pyperclip.copy(text_output)
                      else:
                          # JSON output is a string unless we wrote to a file (then it might be empty)
                          json_output = result if isinstance(result, str) else ""
                          pyperclip.copy(json_output)
          
              # If no output file is specified, print to stdout
              if not output_file:
                  if args.output_format == "text":
                      for line in result:  # type: ignore
                          print(line)
                  else:
                      print(result)  # type: ignore
          
          
          def _read_file_content(file_path: Path) -> str:
              """
              Safely reads text content from the specified file using UTF-8 with error replacement.
              """
              try:
                  return file_path.read_text(encoding="utf-8", errors="replace")
              except Exception as e:
                  return f"<<Error reading file: {e}>>"
          
          
          def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
              """
              Retrieves basic metadata: file size in bytes and last modified time in ISO format.
              """
              size = file_path.stat().st_size
              mtime = file_path.stat().st_mtime
              modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
              return {
                  "size": size,
                  "modified": modified_iso
              }
          
          
          if __name__ == "__main__":
              main()
  📄 CHANGELOG.md
    # Changelog
    
    All notable changes to this project will be documented here.
    
    ## [0.1.0] - 2025-01-19
    ### Added
    - Initial release of DirScribe
    - Recursive directory scanning
    - Optional file-content inclusion via extensions
  📄 CODE_OF_CONDUCT.md
    # Contributor Covenant Code of Conduct
    
    ## Our Pledge
    
    We as members, contributors, and leaders pledge to make participation in our
    community a harassment-free experience for everyone, regardless of age, body size,
    disability, ethnicity, gender identity and expression, level of experience,
    nationality, personal appearance, race, religion, or sexual identity and orientation.
    
    We pledge to act and interact in ways that contribute to an open, welcoming,
    diverse, inclusive, and healthy community.
    
    ## Our Standards
    
    Examples of behavior that contributes to a positive environment:
    - Using welcoming and inclusive language
    - Being respectful of differing viewpoints and experiences
    - Gracefully accepting constructive criticism
    - Focusing on what is best for the community
    
    Examples of unacceptable behavior:
    - The use of sexualized language or imagery, and unwelcome sexual attention
    - Insults or personal attacks
    - Harassment in any form
    - Other conduct which could reasonably be considered inappropriate in a professional setting
    
    ## Enforcement
    
    Instances of abusive, harassing, or otherwise unacceptable behavior may be reported
    by contacting the project team. All complaints will be reviewed and investigated 
    and will result in a response deemed necessary and appropriate to the circumstances.
  📄 CONTRIBUTING.md
    # Contributing to DirScribe
    
    Thank you for your interest in contributing to DirScribe! This document explains how to submit pull requests (PRs), report issues, and follow best practices for a smooth contribution process.
    
    ## Development Setup
    
    1. **Fork** the repository on GitHub, then clone it locally.
    2. Create a feature branch:
       ```bash
       git checkout -b feature/my-awesome-feature
       ```
    3. Install and test the package:
       ```bash
       pip install -e .[dev]
       pytest
       ```
    
    ## Coding Style
    
    * Adhere to PEP 8 for Python code style whenever possible.
    * Write clear docstrings or comments to help others understand your code.
    
    ## Commit Messages
    
    * Keep commit messages concise but descriptive.
    * Make incremental commits that each address a single topic or issue if possible.
    
    ## Pull Requests
    
    1. Verify that all tests pass and your changes are documented.
    2. Open a PR against the `main` branch with a clear title and description.
    3. In the PR body, describe what changes you made and why. Include any relevant issue numbers.
    4. Be prepared to address review feedback; update your branch with additional commits as needed.
    
    ## Issue Reporting
    
    * Use GitHub Issues for bug reports, feature requests, or questions.
    * Provide as much detail as possible, including steps to reproduce bugs if applicable.
    
    ## License
    
    * DirScribe is distributed under the MIT License.
    * Any contributions you make will also fall under that same license.
    
    Thank you for your contributions and support!
  📁 dirscribe/
    📄 __init__.py
      """
      DirScribe
      
      A Python package that helps you export a directory structure and optionally
      the contents of files with certain extensions.
      """
      
      __version__ = "0.1.1"
      
      from .core import export_directory_structure, main
    📁 __pycache__/
      📄 __init__.cpython-310.pyc
      📄 __init__.cpython-39.pyc
      📄 core.cpython-310.pyc
      📄 core.cpython-39.pyc
    📄 core.py
      #!/usr/bin/env python3
      # -*- coding: utf-8 -*-
      
      import argparse
      import json
      import time
      import sys
      from pathlib import Path
      from typing import List, Optional, Union, Dict, Any
      
      try:
          import pyperclip
      except ImportError:
          pyperclip = None
      
      #: A default dictionary for mapping file extensions to language names.
      LANGUAGE_MAP = {
          ".py": "Python",
          ".js": "JavaScript",
          ".ts": "TypeScript",
          ".java": "Java",
          ".rb": "Ruby",
          ".php": "PHP",
          ".html": "HTML",
          ".css": "CSS",
          ".cpp": "C++",
          ".c": "C",
          ".go": "Go",
          ".rs": "Rust",
          ".swift": "Swift",
      }
      
      
      def scan_directory(
          target_dir: Path,
          include_extensions: Optional[List[str]] = None,
          skip_hidden: bool = False,
          max_size: Optional[int] = None,
          show_metadata: bool = False,
          detect_language: bool = False
      ) -> Dict[str, Any]:
          """
          Recursively scans the target directory and builds a nested dictionary
          representing directories and files. File contents are included only for
          certain extensions if specified.
      
          Args:
              target_dir (Path):
                  The directory path to scan.
              include_extensions (List[str], optional):
                  A list of file extensions to include content for. If None, all files are included.
                  If an empty list, no file content is included.
              skip_hidden (bool):
                  If True, hidden files and directories (names starting with '.') are skipped.
              max_size (int, optional):
                  Maximum file size in bytes to read. Files larger than this are skipped.
              show_metadata (bool):
                  If True, file metadata (size, modified time) is included in the output.
              detect_language (bool):
                  If True, a "language" field is added to each file based on extension.
      
          Returns:
              Dict[str, Any]: A nested dictionary describing the directory structure.
          """
          if not target_dir.exists():
              return {
                  "type": "error",
                  "message": f"Directory does not exist: {target_dir}"
              }
      
          tree = {
              "type": "directory",
              "name": target_dir.name,
              "path": str(target_dir.resolve()),
              "children": []
          }
      
          try:
              entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
          except PermissionError:
              tree["children"].append({
                  "type": "error",
                  "message": f"Permission denied: {target_dir}"
              })
              return tree
      
          for entry in entries:
              # Skip hidden files/directories if skip_hidden == True
              if skip_hidden and entry.name.startswith('.'):
                  continue
      
              if entry.is_dir():
                  subtree = scan_directory(
                      entry,
                      include_extensions=include_extensions,
                      skip_hidden=skip_hidden,
                      max_size=max_size,
                      show_metadata=show_metadata,
                      detect_language=detect_language
                  )
                  tree["children"].append(subtree)
              else:
                  file_node = {
                      "type": "file",
                      "name": entry.name,
                      "path": str(entry.resolve())
                  }
      
                  # Detect language if requested
                  if detect_language:
                      lang = LANGUAGE_MAP.get(entry.suffix.lower())
                      if lang:
                          file_node["language"] = lang
      
                  # Show metadata if requested
                  if show_metadata:
                      file_node["metadata"] = _get_file_metadata(entry)
      
                  # Decide if we include the file content
                  if include_extensions and len(include_extensions) > 0:
                      # If we put "ALL_MODE" into include_extensions, treat as "include all"
                      if "ALL_MODE" in include_extensions:
                          should_include = True
                      else:
                          should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                  elif include_extensions is None:
                      # If include_extensions is None, treat as "include all"
                      should_include = True
                  else:
                      # If it's an empty list, do not include file content
                      should_include = False
      
                  if should_include:
                      size = entry.stat().st_size
                      if max_size is not None and size > max_size:
                          file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                      else:
                          file_node["content"] = _read_file_content(entry)
      
                  tree["children"].append(file_node)
      
          return tree
      
      
      def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
          """
          Builds a list of text lines (ASCII tree style) from the nested dictionary.
      
          Args:
              tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
              indent_level (int): Internal parameter for managing indentation in recursion.
      
          Returns:
              List[str]: A list of text lines representing the directory tree and optional contents.
          """
          lines = []
      
          node_type = tree.get("type")
          node_name = tree.get("name", "unknown")
      
          if node_type == "error":
              msg = tree.get("message", "Unknown error")
              lines.append("  " * indent_level + f"[Error] {msg}")
              return lines
      
          if node_type == "directory":
              lines.append("  " * indent_level + f"📁 {node_name}/")
              children = tree.get("children", [])
              for child in children:
                  lines.extend(build_text_output(child, indent_level + 1))
      
          elif node_type == "file":
              language = tree.get("language")
              if language:
                  lines.append("  " * indent_level + f"📄 {node_name} ({language})")
              else:
                  lines.append("  " * indent_level + f"📄 {node_name}")
      
              content = tree.get("content")
              if content is not None:
                  for c_line in content.splitlines():
                      lines.append("  " * (indent_level + 1) + c_line)
      
              metadata = tree.get("metadata")
              if metadata:
                  lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                  lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
      
          return lines
      
      
      def export_directory_structure(
          target_dir: Path,
          include_extensions: Optional[List[str]] = None,
          skip_hidden: bool = False,
          max_size: Optional[int] = None,
          show_metadata: bool = False,
          detect_language: bool = False,
          output_format: str = "text",
          output_file: Optional[Path] = None
      ) -> Union[List[str], str]:
          """
          Scans the directory and produces output in either text or JSON format.
          Optionally writes the result to a file if output_file is specified.
      
          Args:
              target_dir (Path): The directory to scan.
              include_extensions (List[str], optional): File extensions to include contents for.
                  If None, includes all. If empty, includes none.
              skip_hidden (bool): Whether to skip hidden files/directories.
              max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
              show_metadata (bool): Whether to include file metadata in the output.
              detect_language (bool): Whether to add a 'language' field based on file extension.
              output_format (str): 'text' or 'json'. Default is 'text'.
              output_file (Path, optional): If specified, the output is written to this file.
      
          Returns:
              Union[List[str], str]:
                  - If output_format='text' and output_file is None, returns a list of lines.
                  - If output_format='json' and output_file is None, returns a JSON string.
                  - If output_file is specified, writes to file and returns an empty list or string.
          """
          tree = scan_directory(
              target_dir=target_dir,
              include_extensions=include_extensions,
              skip_hidden=skip_hidden,
              max_size=max_size,
              show_metadata=show_metadata,
              detect_language=detect_language
          )
      
          if output_format not in ["text", "json"]:
              raise ValueError("Invalid output format. Choose 'text' or 'json'.")
      
          if output_format == "text":
              output_data = build_text_output(tree)
          else:
              output_data = json.dumps(tree, indent=2)
      
          if output_file is not None:
              if output_format == "text":
                  # output_data is a list of strings
                  text_content = "\n".join(output_data)
                  output_file.write_text(text_content, encoding="utf-8")
                  return []
              else:
                  # output_data is a JSON string
                  output_file.write_text(output_data, encoding="utf-8")
                  return ""
          else:
              return output_data
      
      
      def main():
          """
          CLI entry point for DirScribe. Parses command-line arguments
          and prints or writes the directory structure.
          """
          parser = argparse.ArgumentParser(
              description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
          )
          parser.add_argument("directory", type=str, help="Path to the directory to scan.")
          parser.add_argument(
              "-e", "--extensions", nargs="*", default=[],
              help=(
                  "List of file extensions to include content for (e.g. -e .py .txt). "
                  "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
              )
          )
          parser.add_argument(
              "--skip-hidden", action="store_true",
              help="Skip hidden files and directories."
          )
          parser.add_argument(
              "--max-size", type=int, default=None,
              help="Maximum file size (in bytes) to read. Larger files will be skipped."
          )
          parser.add_argument(
              "--show-metadata", action="store_true",
              help="Include file metadata (size, modified time) in the output."
          )
          parser.add_argument(
              "--detect-language", action="store_true",
              help="Attach a 'language' field based on file extension."
          )
          parser.add_argument(
              "--output-format", choices=["text", "json"], default="text",
              help="Choose output format: 'text' or 'json'. Default is 'text'."
          )
          parser.add_argument(
              "--output-file", type=str, default=None,
              help="If specified, write the output to this file instead of stdout."
          )
          parser.add_argument(
              "--clip", action="store_true",
              help="Copy the output to the clipboard (requires pyperclip)."
          )
      
          args = parser.parse_args()
          directory = Path(args.directory).resolve()
      
          # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
          use_all_extensions = False
          if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
              use_all_extensions = True
      
          if use_all_extensions:
              include_exts = None  # None means "include all file contents"
          else:
              include_exts = args.extensions
      
          output_file = Path(args.output_file).resolve() if args.output_file else None
      
          result = export_directory_structure(
              target_dir=directory,
              include_extensions=include_exts,
              skip_hidden=args.skip_hidden,
              max_size=args.max_size,
              show_metadata=args.show_metadata,
              detect_language=args.detect_language,
              output_format=args.output_format,
              output_file=output_file
          )
      
          # If clipboard copy is requested
          if args.clip:
              if pyperclip is None:
                  print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
              else:
                  if args.output_format == "text":
                      if isinstance(result, list):
                          text_output = "\n".join(result)
                      else:
                          # If an output file was specified, result might be []
                          text_output = "\n".join(result) if result else ""
                      pyperclip.copy(text_output)
                  else:
                      # JSON output is a string unless we wrote to a file (then it might be empty)
                      json_output = result if isinstance(result, str) else ""
                      pyperclip.copy(json_output)
      
          # If no output file is specified, print to stdout
          if not output_file:
              if args.output_format == "text":
                  for line in result:  # type: ignore
                      print(line)
              else:
                  print(result)  # type: ignore
      
      
      def _read_file_content(file_path: Path) -> str:
          """
          Safely reads text content from the specified file using UTF-8 with error replacement.
          """
          try:
              return file_path.read_text(encoding="utf-8", errors="replace")
          except Exception as e:
              return f"<<Error reading file: {e}>>"
      
      
      def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
          """
          Retrieves basic metadata: file size in bytes and last modified time in ISO format.
          """
          size = file_path.stat().st_size
          mtime = file_path.stat().st_mtime
          modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
          return {
              "size": size,
              "modified": modified_iso
          }
      
      
      if __name__ == "__main__":
          main()
  📁 dirscribe.egg-info/
    📄 dependency_links.txt
      
    📄 entry_points.txt
      [console_scripts]
      dirscribe = dirscribe.core:main
    📄 PKG-INFO
    📄 SOURCES.txt
      CHANGELOG.md
      CODE_OF_CONDUCT.md
      CONTRIBUTING.md
      LICENSE
      MANIFEST.in
      README.md
      pyproject.toml
      setup.py
      dirscribe/__init__.py
      dirscribe/core.py
      dirscribe.egg-info/PKG-INFO
      dirscribe.egg-info/SOURCES.txt
      dirscribe.egg-info/dependency_links.txt
      dirscribe.egg-info/entry_points.txt
      dirscribe.egg-info/top_level.txt
      tests/test_basic.py
    📄 top_level.txt
      dirscribe
  📁 dist/
    📄 dirscribe-0.1.2-py3-none-any.whl
    📄 dirscribe-0.1.2.tar.gz
  📄 LICENSE
  📄 MANIFEST.in
  📄 pyproject.toml
  📄 README.md
    # DirScribe — Explore, Document, and Share Your Directory Structures
    
    ![Version](https://img.shields.io/badge/version-0.1.2-blue.svg)
    ![License](https://img.shields.io/badge/license-MIT-green.svg)
    ![Python 3.7+](https://img.shields.io/badge/Python-3.7+-brightgreen.svg)
    ![Stars](https://img.shields.io/github/stars/kkwmr/dirscribe?style=social)
    [![Total Downloads](https://pepy.tech/badge/dirscribe)](https://pepy.tech/project/dirscribe)
    
    DirScribe is a **lightweight yet powerful** CLI tool and Python library for **exporting directory structures** in either **text** or **JSON** format. It helps you **optionally** include file contents, **detect programming languages**, skip hidden items, limit file reading by size, show metadata (size and modification time), and output results directly to your terminal or a file.
    
    > Created by: [Kazuki Kawamura](https://casp.jp) (Caspy /ˈkæspi/, かすぴー)  
    > **License:** [MIT License](./LICENSE)
    
    ## Quick Look
    
    One of DirScribe's key features is how easily it can include file contents by extension.  
    - If you run `dirscribe /path -e .py .txt`, it includes only `.py` and `.txt` files' contents.  
    - **If you run `dirscribe /path -e` with no arguments, it includes *all* file contents** (new in v0.1.2).  
    - If you omit `-e` entirely, no file contents are included—just the directory tree.
    
    Another new feature in v0.1.2 is `--clip`, which copies the final output (text or JSON) to your clipboard for quick sharing.
    
    **Example**:
    ```bash
    dirscribe /path/to/your_project -e .py --clip
    ```
    
    This command shows all .py file contents (skipping other extensions) and copies the result to your clipboard.
    
    Below is a quick text-based preview if you scan a sample project:
    
    ```
    📁 your_project/
      📄 main.py (Python)
        def calculate_total(items):
            return sum(item.price for item in items)
        
        def main():
            print("Processing orders...")
      
      📁 templates/
        📄 index.html (HTML)
          <!DOCTYPE html>
          <html>
            <head><title>My App</title></head>
            <body><h1>Welcome</h1></body>
          </html>
        
        📄 style.css (CSS)
          body {
            margin: 0;
            padding: 20px;
            font-family: sans-serif;
          }
    ```
    
    If you prefer JSON:
    
    ```bash
    dirscribe /path/to/your_project --output-format json
    ```
    
    You get:
    
    ```json
    {
      "type": "directory",
      "name": "your_project",
      "path": "absolute/path/your_project",
      "children": [
        {
          "type": "file",
          "name": "main.py",
          "path": "...",
          "language": "Python",
          "content": "...",
          ...
        },
        ...
      ]
    }
    ```
    
    ## Table of Contents
    - Key Features
    - Why DirScribe?
    - Installation
    - Quick Start
    - Command-Line Usage
    - Python Library Usage
    - Use Cases
    - AI Tools Integration
    - Contributing
    - License
    
    ## Key Features
    
    - Text or JSON Output
      - Choose between a human-readable tree format or a structured JSON representation for advanced integrations.
    
    - File Content Inclusion
      - Display the contents of files for specific extensions (e.g., .py, .js, .txt).
      - Tip: With v0.1.2, if you add `-e` with no extensions, all file contents are included.
    
    - Language Detection
      - Show the programming language name (e.g., .py -> Python) alongside file names.
    
    - Skip Hidden
      - Omit hidden files and directories (names starting with a dot).
    
    - Maximum Size Limit
      - Automatically skip file content if a file exceeds a specified byte-size.
    
    - Metadata Display
      - Show file size and last modification timestamp in the output.
    
    - Clipboard Copy
      - Use `--clip` to copy the output directly to your clipboard (requires pyperclip).
    
    - Save to File
      - Output can be redirected to a file rather than just printing to the console.
    
    - Highly Configurable
      - Combine various options to fit your exact needs.
    
    ## Why DirScribe?
    
    - Instant Documentation
      - Quickly generate a snapshot of your codebase – perfect for onboarding new team members or archiving project structures.
    
    - Efficient Code Reviews
      - Include file contents up to a specified size, letting you skim important files without diving deeply into each folder.
    
    - Language Insights
      - Recognize the languages used in your project at a glance.
    
    - Scriptable
      - Integrate DirScribe into CI/CD pipelines or other automated workflows to maintain updated structure maps.
    
    - Open Source & Community-Driven
      - MIT-licensed, easily extended, and continuously improved by the community.
    
    ## Installation
    
    You can install DirScribe by cloning the repository and running:
    
    ```bash
    pip install .
    ```
    
    If you're actively editing the source, you might prefer:
    
    ```bash
    pip install -e .
    ```
    
    This sets up DirScribe in "editable" mode so changes in the code take immediate effect.
    
    If DirScribe is published on PyPI in the future, you'll be able to do:
    
    ```bash
    pip install dirscribe
    ```
    
    directly.
    
    ## Quick Start
    
    Generate a text listing of a directory:
    
    ```bash
    dirscribe /path/to/project
    ```
    
    Generate a JSON output and save it to a file:
    
    ```bash
    dirscribe /path/to/project --output-format json --output-file project_structure.json
    ```
    
    Include all file contents (no matter the extension):
    
    ```bash
    dirscribe /path/to/project -e
    ```
    
    Copy the result to your clipboard (also new in 0.1.2):
    
    ```bash
    dirscribe /path/to/project --clip
    ```
    
    That's it! Mix and match the options below for your needs.
    
    ## Command-Line Usage
    
    Once installed, you can run dirscribe:
    
    ```
    dirscribe [DIRECTORY] [OPTIONS]
    ```
    
    ### Common Options
    
    - `-e, --extensions <EXT ...>`
      - Specify which file extensions to include content for (e.g., `-e .py .js`).
      - If you pass `-e` with no extensions, DirScribe will include the contents of all files.
      - If you omit `-e` entirely, it includes no file contents.
    
    - `--detect-language`
      - Enables language detection based on file extensions (e.g., .py -> Python).
    
    - `--skip-hidden`
      - Skips files and directories whose names begin with `.`.
    
    - `--max-size <BYTES>`
      - Maximum file size (in bytes) to read. Files larger than this are ignored.
    
    - `--show-metadata`
      - Displays file metadata (size in bytes, last modification time) next to file content.
    
    - `--output-format <text|json>`
      - Output either a text-based tree or JSON structure. Defaults to text.
    
    - `--output-file <FILE>`
      - Write the output to the specified file instead of printing to stdout.
    
    - `--clip`
      - Copy the final output to your clipboard (requires pyperclip).
    
    ### Example: Combine Multiple Options
    
    ```bash
    dirscribe /path/to/src \
      -e .py .html \
      --detect-language \
      --skip-hidden \
      --max-size 2000 \
      --show-metadata \
      --output-format text \
      --output-file output.txt
    ```
    
    What this does:
    1. Recursively scans `/path/to/src`
    2. Shows contents of files with .py or .html extension (up to 2000 bytes)
    3. Skips hidden items (names starting with a dot)
    4. Displays file size & last modified time
    5. Identifies language names where possible
    6. Renders as a textual tree
    7. Saves it to output.txt (instead of printing to the terminal)
    
    ## Python Library Usage
    
    DirScribe can also be used as a library:
    
    ```python
    from pathlib import Path
    from dirscribe.core import export_directory_structure
    
    def main():
        directory = Path("/path/to/src")
        
        # Export directory structure as text (list of lines)
        lines = export_directory_structure(
            target_dir=directory,
            include_extensions=[".py", ".html"],
            skip_hidden=True,
            max_size=2000,
            show_metadata=True,
            detect_language=True,
            output_format="text",
            output_file=None
        )
        
        # If output_format="text" and output_file=None, you get a list of lines
        for line in lines:
            print(line)
    
    if __name__ == "__main__":
        main()
    ```
    
    ### Parameters
    
    - `target_dir` (Path)
      - The folder you want to scan.
    
    - `include_extensions` (List[str], optional)
      - File extensions for which file contents should be included.
      - Pass None or use `-e` with no args to include all files.
    
    - `skip_hidden` (bool, default=False)
      - Skip hidden files and directories.
    
    - `max_size` (int, optional)
      - Skip content for files larger than this size.
    
    - `show_metadata` (bool, default=False)
      - Show file size and last modification time.
    
    - `detect_language` (bool, default=False)
      - Attach a language field based on file extension (e.g., .py -> Python).
    
    - `output_format` (str, default="text")
      - Either "text" or "json".
    
    - `output_file` (Path, optional)
      - If provided, the data is written to that file. Returns empty list/string.
    
    ### Return Values:
    
    - If `output_format="text"` and `output_file=None`, returns a list of text lines.
    - If `output_format="json"` and `output_file=None`, returns a JSON string.
    - If `output_file` is set, writes to that file and returns an empty list or empty string.
    
    ## Use Cases
    
    ### Instant Project Documentation
    Generate a tree-like structure of your source code, optionally with file contents.
    Great for sharing with collaborators or creating "at-a-glance" docs.
    
    ### Code Review & Auditing
    Quickly see which files exist, their languages, and read short/medium files directly.
    
    ### Security / Compliance Checks
    Skip hidden or large files, or selectively scan certain file types.
    
    ### CI/CD Integration
    Save a JSON manifest of your repository structure as part of your build artifacts.
    Compare structure between builds or track changes over time.
    
    ### Scripting / Automation
    Leverage DirScribe's JSON or text output in custom pipelines or scripts.
    
    ## AI Tools Integration
    
    DirScribe's output is perfect for feeding into ChatGPT or other AI tools to analyze or summarize a project's structure:
    
    1. Generate a text or JSON snapshot:
    ```bash
    dirscribe /path/to/src --output-format text > structure.txt
    ```
    
    2. Copy/paste structure.txt into ChatGPT (or your AI tool).
    
    3. Ask questions like:
       - "Give me an overview of this project."
       - "Identify potential security concerns."
       - "Suggest improvements or refactoring ideas."
    
    By providing AI with a precise structure (and optionally file contents), you can quickly gain insights or documentation without manual exploration.
    
    ## Contributing
    
    We welcome contributions, suggestions, and bug reports! See our CONTRIBUTING.md to learn how to propose changes or open pull requests. We also encourage you to open an issue for any problems or feature requests.
    
    Ways to help:
    - Code contributions (new features, bug fixes, refactoring)
    - Documentation improvements (clarify instructions, add examples)
    - Language mapping expansions (add more file extensions to LANGUAGE_MAP)
    - Feedback and testing on different OS environments or large-scale projects
    
    If you find DirScribe valuable, please star the repository and share it with fellow developers!
    
    ## License
    
    This project is distributed under the MIT License.
    © 2025 Kazuki Kawamura
  📄 requirements-dev.txt
    pytest==7.3.1
  📄 setup.py
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    
    import os
    from setuptools import setup, find_packages
    
    
    this_directory = os.path.abspath(os.path.dirname(__file__))
    with open(os.path.join(this_directory, "README.md"), encoding="utf-8") as f:
        long_description = f.read()
    
    setup(
        name="dirscribe",
        version="0.1.2",
        description="A tool to export directory structure and optionally include file contents for selected extensions.",
        long_description=long_description,
        long_description_content_type="text/markdown", 
        author="Kazuki Kawamura",
        url="https://github.com/kkwmr/dirscribe",
        packages=find_packages(),
        python_requires=">=3.7",
        entry_points={
            "console_scripts": [
                "dirscribe=dirscribe.core:main"
            ]
        },
        classifiers=[
            "Programming Language :: Python :: 3",
            "License :: OSI Approved :: MIT License",
            "Operating System :: OS Independent"
        ],
        license="MIT"
    )
  📄 test.txt
    📁 dirscribe/
      📁 .git/
        📁 branches/
        📄 COMMIT_EDITMSG
        📄 config
        📄 description
        📄 HEAD
        📁 hooks/
          📄 applypatch-msg.sample
          📄 commit-msg.sample
          📄 fsmonitor-watchman.sample
          📄 post-update.sample
          📄 pre-applypatch.sample
          📄 pre-commit.sample
          📄 pre-merge-commit.sample
          📄 pre-push.sample
          📄 pre-rebase.sample
          📄 pre-receive.sample
          📄 prepare-commit-msg.sample
          📄 update.sample
        📄 index
        📁 info/
          📄 exclude
        📁 logs/
          📄 HEAD
          📁 refs/
            📁 heads/
              📄 main
            📁 remotes/
              📁 origin/
                📄 main
        📁 objects/
          📁 0e/
            📄 7b24d3c34ff1d4f57029e12a0ed9a447afc2e1
          📁 18/
            📄 0791f3b9750e562dd96939752106089b678e2b
          📁 19/
            📄 1099e8aa4bc3b49c9f10485f3c83a258acb36b
          📁 1b/
            📄 ae5d2e49942d13594c6f3aa2ea29915adf7b37
          📁 36/
            📄 a73a7afd60aa9f24af32c3fccc8ec2f7f39fed
          📁 3b/
            📄 94d9b6343d903a398527621d433e935b852607
          📁 44/
            📄 54c8b82a45039e7129ba452368536bf60268ae
          📁 4d/
            📄 173a646bbdf257211ae246a798dff4724e7f51
          📁 54/
            📄 02ad3b254c098c7fe5074501f5fbddfe1bc25c
          📁 55/
            📄 abe6269ff8a230d10ae9d88f3a45f73998026c
          📁 5f/
            📄 73c6ac039b84b5835e2ad4323a6cf9087ca84c
          📁 60/
            📄 3d4f67046cbfb5452df33959b64995d8f848a4
          📁 61/
            📄 9c23f76d0be9c213f69f54b83d925f53d85792
          📁 71/
            📄 77ec5c59c262e95e9d3e29f9900d640eb1209b
          📁 72/
            📄 a99349f92ad6cdf65b86bcbc17e0115b0052c1
          📁 7e/
            📄 b8a4a6807e48be35fdf1f129907e75229bf495
          📁 8a/
            📄 224a9eb9417670b1ca1a82b17f81b80651eb5b
          📁 97/
            📄 87c3bdf008a57ae3cb2e27a8261eb3f134ff73
          📁 a5/
            📄 b8b5610c39736debb58063a66d941589b31c01
          📁 a9/
            📄 4546d944b15cdcb850afefd6575a1def7d9462
          📁 b8/
            📄 0111c16d345d531c50507f3301a30437eff486
          📁 bf/
            📄 c68f8759cfb2bc629a1dab54353f0c61a41334
          📁 c4/
            📄 d04a08d024e901bb246cc8da9ccf6b49b31909
          📁 ca/
            📄 1a7e5856f6d86106b40128981418e08b71627b
          📁 d5/
            📄 3f8116ec79e4e38df364ca416ec71fc908ba19
          📁 d9/
            📄 8dc5e36cf0c651f2b0bc0702d6fa5f339eba09
          📁 e0/
            📄 35be5e92bb7fb071ed5bf616b35c8d449b61f3
          📁 f6/
            📄 c100e6d7b8539053c2afec43081ab07715f2ea
          📁 fb/
            📄 96d0eb93178eaabf8967073e8a2a6d0b8b03a6
            📄 fd31beab538a41c3d047db65f569f8dac09885
          📁 info/
          📁 pack/
        📁 refs/
          📁 heads/
            📄 main
          📁 remotes/
            📁 origin/
              📄 main
          📁 tags/
            📄 v0.1.0
            📄 v0.1.1
      📄 .gitignore
      📁 .pytest_cache/
        📄 .gitignore
        📄 CACHEDIR.TAG
        📄 README.md
        📁 v/
          📁 cache/
            📄 lastfailed
            📄 nodeids
            📄 stepwise
      📁 build/
        📁 bdist.linux-x86_64/
        📁 lib/
          📁 dirscribe/
            📄 __init__.py
              """
              DirScribe
              
              A Python package that helps you export a directory structure and optionally
              the contents of files with certain extensions.
              """
              
              __version__ = "0.1.1"
              
              from .core import export_directory_structure, main
            📄 core.py
              #!/usr/bin/env python3
              # -*- coding: utf-8 -*-
              
              import argparse
              import json
              import time
              import sys
              from pathlib import Path
              from typing import List, Optional, Union, Dict, Any
              
              try:
                  import pyperclip
              except ImportError:
                  pyperclip = None
              
              #: A default dictionary for mapping file extensions to language names.
              LANGUAGE_MAP = {
                  ".py": "Python",
                  ".js": "JavaScript",
                  ".ts": "TypeScript",
                  ".java": "Java",
                  ".rb": "Ruby",
                  ".php": "PHP",
                  ".html": "HTML",
                  ".css": "CSS",
                  ".cpp": "C++",
                  ".c": "C",
                  ".go": "Go",
                  ".rs": "Rust",
                  ".swift": "Swift",
              }
              
              
              def scan_directory(
                  target_dir: Path,
                  include_extensions: Optional[List[str]] = None,
                  skip_hidden: bool = False,
                  max_size: Optional[int] = None,
                  show_metadata: bool = False,
                  detect_language: bool = False
              ) -> Dict[str, Any]:
                  """
                  Recursively scans the target directory and builds a nested dictionary
                  representing directories and files. File contents are included only for
                  certain extensions if specified.
              
                  Args:
                      target_dir (Path):
                          The directory path to scan.
                      include_extensions (List[str], optional):
                          A list of file extensions to include content for. If None, all files are included.
                          If an empty list, no file content is included.
                      skip_hidden (bool):
                          If True, hidden files and directories (names starting with '.') are skipped.
                      max_size (int, optional):
                          Maximum file size in bytes to read. Files larger than this are skipped.
                      show_metadata (bool):
                          If True, file metadata (size, modified time) is included in the output.
                      detect_language (bool):
                          If True, a "language" field is added to each file based on extension.
              
                  Returns:
                      Dict[str, Any]: A nested dictionary describing the directory structure.
                  """
                  if not target_dir.exists():
                      return {
                          "type": "error",
                          "message": f"Directory does not exist: {target_dir}"
                      }
              
                  tree = {
                      "type": "directory",
                      "name": target_dir.name,
                      "path": str(target_dir.resolve()),
                      "children": []
                  }
              
                  try:
                      entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
                  except PermissionError:
                      tree["children"].append({
                          "type": "error",
                          "message": f"Permission denied: {target_dir}"
                      })
                      return tree
              
                  for entry in entries:
                      # Skip hidden files/directories if skip_hidden == True
                      if skip_hidden and entry.name.startswith('.'):
                          continue
              
                      if entry.is_dir():
                          subtree = scan_directory(
                              entry,
                              include_extensions=include_extensions,
                              skip_hidden=skip_hidden,
                              max_size=max_size,
                              show_metadata=show_metadata,
                              detect_language=detect_language
                          )
                          tree["children"].append(subtree)
                      else:
                          file_node = {
                              "type": "file",
                              "name": entry.name,
                              "path": str(entry.resolve())
                          }
              
                          # Detect language if requested
                          if detect_language:
                              lang = LANGUAGE_MAP.get(entry.suffix.lower())
                              if lang:
                                  file_node["language"] = lang
              
                          # Show metadata if requested
                          if show_metadata:
                              file_node["metadata"] = _get_file_metadata(entry)
              
                          # Decide if we include the file content
                          if include_extensions and len(include_extensions) > 0:
                              # If we put "ALL_MODE" into include_extensions, treat as "include all"
                              if "ALL_MODE" in include_extensions:
                                  should_include = True
                              else:
                                  should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                          elif include_extensions is None:
                              # If include_extensions is None, treat as "include all"
                              should_include = True
                          else:
                              # If it's an empty list, do not include file content
                              should_include = False
              
                          if should_include:
                              size = entry.stat().st_size
                              if max_size is not None and size > max_size:
                                  file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                              else:
                                  file_node["content"] = _read_file_content(entry)
              
                          tree["children"].append(file_node)
              
                  return tree
              
              
              def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
                  """
                  Builds a list of text lines (ASCII tree style) from the nested dictionary.
              
                  Args:
                      tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
                      indent_level (int): Internal parameter for managing indentation in recursion.
              
                  Returns:
                      List[str]: A list of text lines representing the directory tree and optional contents.
                  """
                  lines = []
              
                  node_type = tree.get("type")
                  node_name = tree.get("name", "unknown")
              
                  if node_type == "error":
                      msg = tree.get("message", "Unknown error")
                      lines.append("  " * indent_level + f"[Error] {msg}")
                      return lines
              
                  if node_type == "directory":
                      lines.append("  " * indent_level + f"📁 {node_name}/")
                      children = tree.get("children", [])
                      for child in children:
                          lines.extend(build_text_output(child, indent_level + 1))
              
                  elif node_type == "file":
                      language = tree.get("language")
                      if language:
                          lines.append("  " * indent_level + f"📄 {node_name} ({language})")
                      else:
                          lines.append("  " * indent_level + f"📄 {node_name}")
              
                      content = tree.get("content")
                      if content is not None:
                          for c_line in content.splitlines():
                              lines.append("  " * (indent_level + 1) + c_line)
              
                      metadata = tree.get("metadata")
                      if metadata:
                          lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                          lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
              
                  return lines
              
              
              def export_directory_structure(
                  target_dir: Path,
                  include_extensions: Optional[List[str]] = None,
                  skip_hidden: bool = False,
                  max_size: Optional[int] = None,
                  show_metadata: bool = False,
                  detect_language: bool = False,
                  output_format: str = "text",
                  output_file: Optional[Path] = None
              ) -> Union[List[str], str]:
                  """
                  Scans the directory and produces output in either text or JSON format.
                  Optionally writes the result to a file if output_file is specified.
              
                  Args:
                      target_dir (Path): The directory to scan.
                      include_extensions (List[str], optional): File extensions to include contents for.
                          If None, includes all. If empty, includes none.
                      skip_hidden (bool): Whether to skip hidden files/directories.
                      max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
                      show_metadata (bool): Whether to include file metadata in the output.
                      detect_language (bool): Whether to add a 'language' field based on file extension.
                      output_format (str): 'text' or 'json'. Default is 'text'.
                      output_file (Path, optional): If specified, the output is written to this file.
              
                  Returns:
                      Union[List[str], str]:
                          - If output_format='text' and output_file is None, returns a list of lines.
                          - If output_format='json' and output_file is None, returns a JSON string.
                          - If output_file is specified, writes to file and returns an empty list or string.
                  """
                  tree = scan_directory(
                      target_dir=target_dir,
                      include_extensions=include_extensions,
                      skip_hidden=skip_hidden,
                      max_size=max_size,
                      show_metadata=show_metadata,
                      detect_language=detect_language
                  )
              
                  if output_format not in ["text", "json"]:
                      raise ValueError("Invalid output format. Choose 'text' or 'json'.")
              
                  if output_format == "text":
                      output_data = build_text_output(tree)
                  else:
                      output_data = json.dumps(tree, indent=2)
              
                  if output_file is not None:
                      if output_format == "text":
                          # output_data is a list of strings
                          text_content = "\n".join(output_data)
                          output_file.write_text(text_content, encoding="utf-8")
                          return []
                      else:
                          # output_data is a JSON string
                          output_file.write_text(output_data, encoding="utf-8")
                          return ""
                  else:
                      return output_data
              
              
              def main():
                  """
                  CLI entry point for DirScribe. Parses command-line arguments
                  and prints or writes the directory structure.
                  """
                  parser = argparse.ArgumentParser(
                      description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
                  )
                  parser.add_argument("directory", type=str, help="Path to the directory to scan.")
                  parser.add_argument(
                      "-e", "--extensions", nargs="*", default=[],
                      help=(
                          "List of file extensions to include content for (e.g. -e .py .txt). "
                          "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
                      )
                  )
                  parser.add_argument(
                      "--skip-hidden", action="store_true",
                      help="Skip hidden files and directories."
                  )
                  parser.add_argument(
                      "--max-size", type=int, default=None,
                      help="Maximum file size (in bytes) to read. Larger files will be skipped."
                  )
                  parser.add_argument(
                      "--show-metadata", action="store_true",
                      help="Include file metadata (size, modified time) in the output."
                  )
                  parser.add_argument(
                      "--detect-language", action="store_true",
                      help="Attach a 'language' field based on file extension."
                  )
                  parser.add_argument(
                      "--output-format", choices=["text", "json"], default="text",
                      help="Choose output format: 'text' or 'json'. Default is 'text'."
                  )
                  parser.add_argument(
                      "--output-file", type=str, default=None,
                      help="If specified, write the output to this file instead of stdout."
                  )
                  parser.add_argument(
                      "--clip", action="store_true",
                      help="Copy the output to the clipboard (requires pyperclip)."
                  )
              
                  args = parser.parse_args()
                  directory = Path(args.directory).resolve()
              
                  # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
                  use_all_extensions = False
                  if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
                      use_all_extensions = True
              
                  if use_all_extensions:
                      include_exts = None  # None means "include all file contents"
                  else:
                      include_exts = args.extensions
              
                  output_file = Path(args.output_file).resolve() if args.output_file else None
              
                  result = export_directory_structure(
                      target_dir=directory,
                      include_extensions=include_exts,
                      skip_hidden=args.skip_hidden,
                      max_size=args.max_size,
                      show_metadata=args.show_metadata,
                      detect_language=args.detect_language,
                      output_format=args.output_format,
                      output_file=output_file
                  )
              
                  # If clipboard copy is requested
                  if args.clip:
                      if pyperclip is None:
                          print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
                      else:
                          if args.output_format == "text":
                              if isinstance(result, list):
                                  text_output = "\n".join(result)
                              else:
                                  # If an output file was specified, result might be []
                                  text_output = "\n".join(result) if result else ""
                              pyperclip.copy(text_output)
                          else:
                              # JSON output is a string unless we wrote to a file (then it might be empty)
                              json_output = result if isinstance(result, str) else ""
                              pyperclip.copy(json_output)
              
                  # If no output file is specified, print to stdout
                  if not output_file:
                      if args.output_format == "text":
                          for line in result:  # type: ignore
                              print(line)
                      else:
                          print(result)  # type: ignore
              
              
              def _read_file_content(file_path: Path) -> str:
                  """
                  Safely reads text content from the specified file using UTF-8 with error replacement.
                  """
                  try:
                      return file_path.read_text(encoding="utf-8", errors="replace")
                  except Exception as e:
                      return f"<<Error reading file: {e}>>"
              
              
              def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
                  """
                  Retrieves basic metadata: file size in bytes and last modified time in ISO format.
                  """
                  size = file_path.stat().st_size
                  mtime = file_path.stat().st_mtime
                  modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
                  return {
                      "size": size,
                      "modified": modified_iso
                  }
              
              
              if __name__ == "__main__":
                  main()
      📄 CHANGELOG.md
      📄 CODE_OF_CONDUCT.md
      📄 CONTRIBUTING.md
      📁 dirscribe/
        📄 __init__.py
          """
          DirScribe
          
          A Python package that helps you export a directory structure and optionally
          the contents of files with certain extensions.
          """
          
          __version__ = "0.1.1"
          
          from .core import export_directory_structure, main
        📁 __pycache__/
          📄 __init__.cpython-310.pyc
          📄 __init__.cpython-39.pyc
          📄 core.cpython-310.pyc
          📄 core.cpython-39.pyc
        📄 core.py
          #!/usr/bin/env python3
          # -*- coding: utf-8 -*-
          
          import argparse
          import json
          import time
          import sys
          from pathlib import Path
          from typing import List, Optional, Union, Dict, Any
          
          try:
              import pyperclip
          except ImportError:
              pyperclip = None
          
          #: A default dictionary for mapping file extensions to language names.
          LANGUAGE_MAP = {
              ".py": "Python",
              ".js": "JavaScript",
              ".ts": "TypeScript",
              ".java": "Java",
              ".rb": "Ruby",
              ".php": "PHP",
              ".html": "HTML",
              ".css": "CSS",
              ".cpp": "C++",
              ".c": "C",
              ".go": "Go",
              ".rs": "Rust",
              ".swift": "Swift",
          }
          
          
          def scan_directory(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False
          ) -> Dict[str, Any]:
              """
              Recursively scans the target directory and builds a nested dictionary
              representing directories and files. File contents are included only for
              certain extensions if specified.
          
              Args:
                  target_dir (Path):
                      The directory path to scan.
                  include_extensions (List[str], optional):
                      A list of file extensions to include content for. If None, all files are included.
                      If an empty list, no file content is included.
                  skip_hidden (bool):
                      If True, hidden files and directories (names starting with '.') are skipped.
                  max_size (int, optional):
                      Maximum file size in bytes to read. Files larger than this are skipped.
                  show_metadata (bool):
                      If True, file metadata (size, modified time) is included in the output.
                  detect_language (bool):
                      If True, a "language" field is added to each file based on extension.
          
              Returns:
                  Dict[str, Any]: A nested dictionary describing the directory structure.
              """
              if not target_dir.exists():
                  return {
                      "type": "error",
                      "message": f"Directory does not exist: {target_dir}"
                  }
          
              tree = {
                  "type": "directory",
                  "name": target_dir.name,
                  "path": str(target_dir.resolve()),
                  "children": []
              }
          
              try:
                  entries = sorted(target_dir.iterdir(), key=lambda x: x.name.lower())
              except PermissionError:
                  tree["children"].append({
                      "type": "error",
                      "message": f"Permission denied: {target_dir}"
                  })
                  return tree
          
              for entry in entries:
                  # Skip hidden files/directories if skip_hidden == True
                  if skip_hidden and entry.name.startswith('.'):
                      continue
          
                  if entry.is_dir():
                      subtree = scan_directory(
                          entry,
                          include_extensions=include_extensions,
                          skip_hidden=skip_hidden,
                          max_size=max_size,
                          show_metadata=show_metadata,
                          detect_language=detect_language
                      )
                      tree["children"].append(subtree)
                  else:
                      file_node = {
                          "type": "file",
                          "name": entry.name,
                          "path": str(entry.resolve())
                      }
          
                      # Detect language if requested
                      if detect_language:
                          lang = LANGUAGE_MAP.get(entry.suffix.lower())
                          if lang:
                              file_node["language"] = lang
          
                      # Show metadata if requested
                      if show_metadata:
                          file_node["metadata"] = _get_file_metadata(entry)
          
                      # Decide if we include the file content
                      if include_extensions and len(include_extensions) > 0:
                          # If we put "ALL_MODE" into include_extensions, treat as "include all"
                          if "ALL_MODE" in include_extensions:
                              should_include = True
                          else:
                              should_include = (entry.suffix.lower() in [ext.lower() for ext in include_extensions])
                      elif include_extensions is None:
                          # If include_extensions is None, treat as "include all"
                          should_include = True
                      else:
                          # If it's an empty list, do not include file content
                          should_include = False
          
                      if should_include:
                          size = entry.stat().st_size
                          if max_size is not None and size > max_size:
                              file_node["content"] = f"<<File size exceeds {max_size} bytes, skipping content>>"
                          else:
                              file_node["content"] = _read_file_content(entry)
          
                      tree["children"].append(file_node)
          
              return tree
          
          
          def build_text_output(tree: Dict[str, Any], indent_level: int = 0) -> List[str]:
              """
              Builds a list of text lines (ASCII tree style) from the nested dictionary.
          
              Args:
                  tree (Dict[str, Any]): The directory structure dictionary returned by scan_directory().
                  indent_level (int): Internal parameter for managing indentation in recursion.
          
              Returns:
                  List[str]: A list of text lines representing the directory tree and optional contents.
              """
              lines = []
          
              node_type = tree.get("type")
              node_name = tree.get("name", "unknown")
          
              if node_type == "error":
                  msg = tree.get("message", "Unknown error")
                  lines.append("  " * indent_level + f"[Error] {msg}")
                  return lines
          
              if node_type == "directory":
                  lines.append("  " * indent_level + f"📁 {node_name}/")
                  children = tree.get("children", [])
                  for child in children:
                      lines.extend(build_text_output(child, indent_level + 1))
          
              elif node_type == "file":
                  language = tree.get("language")
                  if language:
                      lines.append("  " * indent_level + f"📄 {node_name} ({language})")
                  else:
                      lines.append("  " * indent_level + f"📄 {node_name}")
          
                  content = tree.get("content")
                  if content is not None:
                      for c_line in content.splitlines():
                          lines.append("  " * (indent_level + 1) + c_line)
          
                  metadata = tree.get("metadata")
                  if metadata:
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Size: {metadata['size']} bytes")
                      lines.append("  " * (indent_level + 1) + f"[Metadata] Modified: {metadata['modified']}")
          
              return lines
          
          
          def export_directory_structure(
              target_dir: Path,
              include_extensions: Optional[List[str]] = None,
              skip_hidden: bool = False,
              max_size: Optional[int] = None,
              show_metadata: bool = False,
              detect_language: bool = False,
              output_format: str = "text",
              output_file: Optional[Path] = None
          ) -> Union[List[str], str]:
              """
              Scans the directory and produces output in either text or JSON format.
              Optionally writes the result to a file if output_file is specified.
          
              Args:
                  target_dir (Path): The directory to scan.
                  include_extensions (List[str], optional): File extensions to include contents for.
                      If None, includes all. If empty, includes none.
                  skip_hidden (bool): Whether to skip hidden files/directories.
                  max_size (int, optional): Maximum file size in bytes to read. Larger files are skipped.
                  show_metadata (bool): Whether to include file metadata in the output.
                  detect_language (bool): Whether to add a 'language' field based on file extension.
                  output_format (str): 'text' or 'json'. Default is 'text'.
                  output_file (Path, optional): If specified, the output is written to this file.
          
              Returns:
                  Union[List[str], str]:
                      - If output_format='text' and output_file is None, returns a list of lines.
                      - If output_format='json' and output_file is None, returns a JSON string.
                      - If output_file is specified, writes to file and returns an empty list or string.
              """
              tree = scan_directory(
                  target_dir=target_dir,
                  include_extensions=include_extensions,
                  skip_hidden=skip_hidden,
                  max_size=max_size,
                  show_metadata=show_metadata,
                  detect_language=detect_language
              )
          
              if output_format not in ["text", "json"]:
                  raise ValueError("Invalid output format. Choose 'text' or 'json'.")
          
              if output_format == "text":
                  output_data = build_text_output(tree)
              else:
                  output_data = json.dumps(tree, indent=2)
          
              if output_file is not None:
                  if output_format == "text":
                      # output_data is a list of strings
                      text_content = "\n".join(output_data)
                      output_file.write_text(text_content, encoding="utf-8")
                      return []
                  else:
                      # output_data is a JSON string
                      output_file.write_text(output_data, encoding="utf-8")
                      return ""
              else:
                  return output_data
          
          
          def main():
              """
              CLI entry point for DirScribe. Parses command-line arguments
              and prints or writes the directory structure.
              """
              parser = argparse.ArgumentParser(
                  description="DirScribe: Export a directory structure in text or JSON format, with optional file content."
              )
              parser.add_argument("directory", type=str, help="Path to the directory to scan.")
              parser.add_argument(
                  "-e", "--extensions", nargs="*", default=[],
                  help=(
                      "List of file extensions to include content for (e.g. -e .py .txt). "
                      "If '-e' or '--extensions' is passed with no arguments, all file contents will be included."
                  )
              )
              parser.add_argument(
                  "--skip-hidden", action="store_true",
                  help="Skip hidden files and directories."
              )
              parser.add_argument(
                  "--max-size", type=int, default=None,
                  help="Maximum file size (in bytes) to read. Larger files will be skipped."
              )
              parser.add_argument(
                  "--show-metadata", action="store_true",
                  help="Include file metadata (size, modified time) in the output."
              )
              parser.add_argument(
                  "--detect-language", action="store_true",
                  help="Attach a 'language' field based on file extension."
              )
              parser.add_argument(
                  "--output-format", choices=["text", "json"], default="text",
                  help="Choose output format: 'text' or 'json'. Default is 'text'."
              )
              parser.add_argument(
                  "--output-file", type=str, default=None,
                  help="If specified, write the output to this file instead of stdout."
              )
              parser.add_argument(
                  "--clip", action="store_true",
                  help="Copy the output to the clipboard (requires pyperclip)."
              )
          
              args = parser.parse_args()
              directory = Path(args.directory).resolve()
          
              # If '-e' or '--extensions' is explicitly given but no extensions are listed, include all contents
              use_all_extensions = False
              if (("-e" in sys.argv) or ("--extensions" in sys.argv)) and len(args.extensions) == 0:
                  use_all_extensions = True
          
              if use_all_extensions:
                  include_exts = None  # None means "include all file contents"
              else:
                  include_exts = args.extensions
          
              output_file = Path(args.output_file).resolve() if args.output_file else None
          
              result = export_directory_structure(
                  target_dir=directory,
                  include_extensions=include_exts,
                  skip_hidden=args.skip_hidden,
                  max_size=args.max_size,
                  show_metadata=args.show_metadata,
                  detect_language=args.detect_language,
                  output_format=args.output_format,
                  output_file=output_file
              )
          
              # If clipboard copy is requested
              if args.clip:
                  if pyperclip is None:
                      print("[ERROR] Cannot copy to clipboard because 'pyperclip' is not installed.")
                  else:
                      if args.output_format == "text":
                          if isinstance(result, list):
                              text_output = "\n".join(result)
                          else:
                              # If an output file was specified, result might be []
                              text_output = "\n".join(result) if result else ""
                          pyperclip.copy(text_output)
                      else:
                          # JSON output is a string unless we wrote to a file (then it might be empty)
                          json_output = result if isinstance(result, str) else ""
                          pyperclip.copy(json_output)
          
              # If no output file is specified, print to stdout
              if not output_file:
                  if args.output_format == "text":
                      for line in result:  # type: ignore
                          print(line)
                  else:
                      print(result)  # type: ignore
          
          
          def _read_file_content(file_path: Path) -> str:
              """
              Safely reads text content from the specified file using UTF-8 with error replacement.
              """
              try:
                  return file_path.read_text(encoding="utf-8", errors="replace")
              except Exception as e:
                  return f"<<Error reading file: {e}>>"
          
          
          def _get_file_metadata(file_path: Path) -> Dict[str, Union[int, str]]:
              """
              Retrieves basic metadata: file size in bytes and last modified time in ISO format.
              """
              size = file_path.stat().st_size
              mtime = file_path.stat().st_mtime
              modified_iso = time.strftime("%Y-%m-%dT%H:%M:%S", time.localtime(mtime))
              return {
                  "size": size,
                  "modified": modified_iso
              }
          
          
          if __name__ == "__main__":
              main()
      📁 dirscribe.egg-info/
        📄 dependency_links.txt
        📄 entry_points.txt
        📄 PKG-INFO
        📄 SOURCES.txt
        📄 top_level.txt
      📁 dist/
        📄 dirscribe-0.1.2-py3-none-any.whl
        📄 dirscribe-0.1.2.tar.gz
      📄 LICENSE
      📄 MANIFEST.in
      📄 pyproject.toml
      📄 README.md
      📄 requirements-dev.txt
      📄 setup.py
        #!/usr/bin/env python3
        # -*- coding: utf-8 -*-
        
        import os
        from setuptools import setup, find_packages
        
        
        this_directory = os.path.abspath(os.path.dirname(__file__))
        with open(os.path.join(this_directory, "README.md"), encoding="utf-8") as f:
            long_description = f.read()
        
        setup(
            name="dirscribe",
            version="0.1.2",
            description="A tool to export directory structure and optionally include file contents for selected extensions.",
            long_description=long_description,
            long_description_content_type="text/markdown", 
            author="Kazuki Kawamura",
            url="https://github.com/kkwmr/dirscribe",
            packages=find_packages(),
            python_requires=">=3.7",
            entry_points={
                "console_scripts": [
                    "dirscribe=dirscribe.core:main"
                ]
            },
            classifiers=[
                "Programming Language :: Python :: 3",
                "License :: OSI Approved :: MIT License",
                "Operating System :: OS Independent"
            ],
            license="MIT"
        )
      📄 test.txt
      📁 tests/
        📁 __pycache__/
          📄 test_basic.cpython-27-PYTEST.pyc
          📄 test_basic.cpython-310-pytest-8.3.4.pyc
        📄 test_basic.py
          import tempfile
          from pathlib import Path
          import pytest
          
          from dirscribe.core import (
              export_directory_structure,
              scan_directory
          )
          
          
          def test_scan_empty_directory():
              """
              Tests scanning an empty directory. The result should have no children.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  tree = scan_directory(tmp_path)
                  assert tree["type"] == "directory"
                  assert len(tree["children"]) == 0
          
          
          def test_skip_hidden():
              """
              Tests that hidden files and directories are skipped when skip_hidden=True.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  # Create a hidden file
                  hidden_file = tmp_path / ".hidden.txt"
                  hidden_file.write_text("This is hidden", encoding="utf-8")
          
                  # Create a normal file
                  visible_file = tmp_path / "visible.txt"
                  visible_file.write_text("This is visible", encoding="utf-8")
          
                  tree = scan_directory(tmp_path, skip_hidden=True)
                  # Should see only the visible file
                  children_names = [child["name"] for child in tree["children"]]
                  assert "visible.txt" in children_names
                  assert ".hidden.txt" not in children_names
          
          
          def test_max_size():
              """
              Tests that files exceeding max_size do not have their content read.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  big_file = tmp_path / "bigfile.txt"
                  # Write a large content
                  big_file.write_text("A" * 5000, encoding="utf-8")
          
                  small_file = tmp_path / "smallfile.txt"
                  small_file.write_text("Short content", encoding="utf-8")
          
                  tree = scan_directory(tmp_path, include_extensions=[".txt"], max_size=1000)
                  big_entry = next(child for child in tree["children"] if child["name"] == "bigfile.txt")
                  small_entry = next(child for child in tree["children"] if child["name"] == "smallfile.txt")
          
                  # big file content should be replaced by a skip message
                  assert "content" in big_entry
                  assert "exceeds 1000 bytes" in big_entry["content"]
                  # small file should contain actual content
                  assert small_entry["content"] == "Short content"
          
          
          def test_show_metadata():
              """
              Tests that file metadata is included when show_metadata=True.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  f = tmp_path / "example.txt"
                  f.write_text("Hello World", encoding="utf-8")
          
                  tree = scan_directory(tmp_path, include_extensions=[".txt"], show_metadata=True)
                  file_node = tree["children"][0]
                  assert "metadata" in file_node
                  assert "size" in file_node["metadata"]
                  assert file_node["metadata"]["size"] == len("Hello World")
          
          
          def test_json_output():
              """
              Tests the export_directory_structure output in JSON format.
              Ensures the returned string can be parsed as JSON.
              """
              with tempfile.TemporaryDirectory() as tmpdir:
                  tmp_path = Path(tmpdir)
                  (tmp_path / "test.py").write_text("print('test')", encoding="utf-8")
          
                  output = export_directory_structure(
                      target_dir=tmp_path,
                      include_extensions=[".py"],
                      output_format="json"
                  )
                  import json
                  parsed = json.loads(output)
                  assert parsed["type"] == "directory"
                  assert parsed["children"][0]["name"] == "test.py"
                  assert "print('test')" in parsed["children"][0].get("content", "")
          
          
          if __name__ == "__main__":
              pytest.main([__file__])
  📁 tests/
    📁 __pycache__/
      📄 test_basic.cpython-27-PYTEST.pyc
      📄 test_basic.cpython-310-pytest-8.3.4.pyc
    📄 test_basic.py
      import tempfile
      from pathlib import Path
      import pytest
      
      from dirscribe.core import (
          export_directory_structure,
          scan_directory
      )
      
      
      def test_scan_empty_directory():
          """
          Tests scanning an empty directory. The result should have no children.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              tree = scan_directory(tmp_path)
              assert tree["type"] == "directory"
              assert len(tree["children"]) == 0
      
      
      def test_skip_hidden():
          """
          Tests that hidden files and directories are skipped when skip_hidden=True.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              # Create a hidden file
              hidden_file = tmp_path / ".hidden.txt"
              hidden_file.write_text("This is hidden", encoding="utf-8")
      
              # Create a normal file
              visible_file = tmp_path / "visible.txt"
              visible_file.write_text("This is visible", encoding="utf-8")
      
              tree = scan_directory(tmp_path, skip_hidden=True)
              # Should see only the visible file
              children_names = [child["name"] for child in tree["children"]]
              assert "visible.txt" in children_names
              assert ".hidden.txt" not in children_names
      
      
      def test_max_size():
          """
          Tests that files exceeding max_size do not have their content read.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              big_file = tmp_path / "bigfile.txt"
              # Write a large content
              big_file.write_text("A" * 5000, encoding="utf-8")
      
              small_file = tmp_path / "smallfile.txt"
              small_file.write_text("Short content", encoding="utf-8")
      
              tree = scan_directory(tmp_path, include_extensions=[".txt"], max_size=1000)
              big_entry = next(child for child in tree["children"] if child["name"] == "bigfile.txt")
              small_entry = next(child for child in tree["children"] if child["name"] == "smallfile.txt")
      
              # big file content should be replaced by a skip message
              assert "content" in big_entry
              assert "exceeds 1000 bytes" in big_entry["content"]
              # small file should contain actual content
              assert small_entry["content"] == "Short content"
      
      
      def test_show_metadata():
          """
          Tests that file metadata is included when show_metadata=True.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              f = tmp_path / "example.txt"
              f.write_text("Hello World", encoding="utf-8")
      
              tree = scan_directory(tmp_path, include_extensions=[".txt"], show_metadata=True)
              file_node = tree["children"][0]
              assert "metadata" in file_node
              assert "size" in file_node["metadata"]
              assert file_node["metadata"]["size"] == len("Hello World")
      
      
      def test_json_output():
          """
          Tests the export_directory_structure output in JSON format.
          Ensures the returned string can be parsed as JSON.
          """
          with tempfile.TemporaryDirectory() as tmpdir:
              tmp_path = Path(tmpdir)
              (tmp_path / "test.py").write_text("print('test')", encoding="utf-8")
      
              output = export_directory_structure(
                  target_dir=tmp_path,
                  include_extensions=[".py"],
                  output_format="json"
              )
              import json
              parsed = json.loads(output)
              assert parsed["type"] == "directory"
              assert parsed["children"][0]["name"] == "test.py"
              assert "print('test')" in parsed["children"][0].get("content", "")
      
      
      if __name__ == "__main__":
          pytest.main([__file__])